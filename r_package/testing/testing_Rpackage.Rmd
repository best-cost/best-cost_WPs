---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Test the functions of the bestcost package comparing the results with results from other tools or assessments


# Load packages and data


The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}
# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)

# to set colors in console messages (checking)
library(crayon)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)


```


```{r load bestcost package}
# Load package (either current version or installed version)
devtools::load_all(export_all = FALSE)
library(bestcost)
```


```{r Alternative 1 to load bestcost: Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here: https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT if prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           ref = "HEAD", # Branch name (by default "HEAD") as a string
                           force = TRUE)
}
library(bestcost)
```



```{r Alternative 2 to load bestcost: load zip from local source, eval=FALSE, include=FALSE}
detach("package:bestcost", unload = TRUE) # detach bestcost
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/bestcost_0.0.0.1.zip", repos=NULL, type='source') # Install package from source
library(bestcost)
```


Load the Rdata file that contains all variables needed to run this script.
```{r load data }
load("../testing/input/data/input_data_for_testing_Rpackage.RData")
```



# Calculate health impacts

## Attributable health impact

### Single baseline health data

```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  bestcost::attribute_health_singlebhd_rr(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central,
                estimated_number_of_attributable_cases_lower,
                estimated_number_of_attributable_cases_upper)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```


```{r multiple single exposure value}
# Assess attributable cases for multiple uncertainties at the same time
# i.e. rr, bhd and exp
bestcost_pm_copd_multiple <-
  bestcost::attribute_health_singlebhd_rr(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))


# Assess iteration geographical sections keeping the multiple uncertainties
bestcost_pm_copd_geo <-
  bestcost::attribute_health_singlebhd_rr(
    exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    cutoff = 5,   
    bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info = "PM2.5_copd")

```


```{r single exposure value and relative risk}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  bestcost::attribute_health_singlebhd_rr(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff = airqplus_pm_copd$cut_off_value,   
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd %>%
  dplyr::select(estimated_number_of_attributable_cases_central)%>%
  unlist()


check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)


```


```{r exposure distribution}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel %>%
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(daly)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  bestcost::attribute_health_singlebhd_rr(
    exp_central = niph_noise_ihd_input$exposure_mean,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))


check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  bestcost::attribute_health_singlebhd_rr(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3,
    geo_id_aggregated = rep("ch", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

                                               

```


```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <- 
  niph_noise_ha_excel %>%
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel %>%
        dplyr::filter(exposure_category %in% "Total exposed")%>%
        dplyr::select(number)%>%
        dplyr::pull() %>%
  round(.)

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  bestcost::attribute_health_singlebhd_ar(
    exp_central = niph_noise_ha_input$exposure_mean,
    pop_exp = niph_noise_ha_input$population_exposed_total, 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)



# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  bestcost::attribute_health_singlebhd_ar(
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
    pop_exp = list(runif_with_seed(5,5E3,1E4,1), 
                   runif_with_seed(5,5E3,1E4,2), 
                   runif_with_seed(5,5E3,1E4,3)), 
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r morbidity yld lifetable with single relative risk}

bestcost_pm_yld_singlebhd  <- 
  bestcost::attribute_yld_singlebhd_rr(
    exp_central = 8.85, 
    cutoff = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024


```


### Life table

#### Probability of dying

```{r Probability of dying}

# Remove years over 40 
# because we are going to compare with results up to 39 years old
airqplus_prob_dying_age0to39_multipleYear <- 
  airqplus_deaths_pop_multipleYear%>%
  dplyr::filter(To<40)

# Results from the AirQ+ manual (to be compared with bestcost results)
airqplus_prob_dying_age0to39_singleYear <-
  airqplus_deaths_pop_singleYear%>%
  dplyr::filter(To<40)%>%
  dplyr::mutate(qx = as.numeric(qx))

# Use bestcost function
bestcost_prob_dying <- 
  bestcost::get_prob_dying_by_single_age(
    first_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$From),
    last_age_pop = last(airqplus_prob_dying_age0to39_multipleYear$To),
    interval_age_pop = first(airqplus_prob_dying_age0to39_multipleYear$To) - first(airqplus_prob_dying_age0to39_multipleYear$From)+1,
    population_midyear = airqplus_prob_dying_age0to39_multipleYear$mi,
    deaths = airqplus_prob_dying_age0to39_multipleYear$di,
    fraction_of_year_lived = 0.5
  )


# Compare and show message with colors

if(all((bestcost_prob_dying$prob_dying - 
        airqplus_prob_dying_age0to39_singleYear$qx) < 0.002)){
  cat(paste(crayon::yellow("Bestcost and alternative source with similar results.")))
} else{
    cat(paste(crayon::red("Attention! Check! Bestcost and alternative source with very different results.")))}
# There is a very small deviation 
# due to different rounding 
# (bestcost does not round, while airqplus does)
```


#### Premature deaths

```{r premature deaths with lifetable}
# First obtain probability of dying 
# for total and natural deaths and for male and female separately
# (AirQ+ does not use probability of dying as input data but bestcost does)
# (AirQ+ only uses natural mortality --> different methodological approach)

prob_dying <- list()

for(d in c("natural", "total")){
  for(s in c("male", "female")){
   prob_dying[[d]][[s]] <-
     bestcost::get_prob_dying_by_single_age(
      first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
      interval_age_pop = 
        unique(airqplus_pm_deaths_yll[["pop"]]$age_from... - 
                 airqplus_pm_deaths_yll[["pop"]]$age_from...) + 1,
      population_midyear = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("midyear_population_", s)]),
      deaths = unlist(airqplus_pm_deaths_yll[["pop"]][, paste0("number_of_deaths_", s)]))
  }
}



# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  bestcost::attribute_deaths_lifetable_rr(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...), # From age 0 onwards
    # first_age_pop = 30, # DOESN'T WORK
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    # prob_natural_death_male = prob_dying[["total"]][["male"]]$prob_dying, # Use total probability of dyingin calculations gives same results --> total and natural prob. of dying are the same
    # prob_natural_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    # prob_total_death_male = rep.int(0, times = 100),          # Test: gives same results
    # prob_total_death_female = rep.int(0, times = 100),        # Test: gives same results
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    # min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age) # age 20
    min_age = 20,
    max_age = 100) # age 30

bestcost_pm_deaths_lifetable_airqplus_new <-
  bestcost::attribute_deaths_lifetable_rr_copy(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...), # From age 0 onwards
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = 20)

print("Original function")
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
               result_vector_alternative = c(2600.9, 1371, 3804))

print("Updated function")
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus_new,
               result_vector_alternative = c(2600.9, 1371, 3804))
```



```{r Comparison AirQ+ and BESTCOST premature deaths, eval=FALSE, include=FALSE}
# Combine male and female results
bestcost_pm_deaths_lifetable_total <- cbind(bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["male"]][["erf_ci_central"]]$age,
              bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["male"]][["erf_ci_central"]]$age_end,
              bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["male"]][["erf_ci_central"]]$population_2019+bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["female"]][["erf_ci_central"]]$population_2019,
              bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["male"]][["erf_ci_central"]]$population_2020+
              bestcost_pm_deaths_lifetable_airqplus[["detailed"]][["by_age_year_sex"]][["female"]][["erf_ci_central"]]$population_2020)

# Run lifetable calculations step by step (code copied from function code of "attribute_deaths_lifetable_rr")
input <-
      bestcost::compile_input(
        exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
        exp_lower =  NULL, 
        exp_upper = NULL,
        prop_pop_exp = 1,
        cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
        rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk, 
        rr_lower = NULL, 
        rr_upper = NULL,
        erf_increment = 10,
        erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
        erf_c_central = NULL,
        erf_c_lower = NULL,
        erf_c_upper = NULL,
        min_age = 30,
        max_age = NULL,
        info = NULL,
        method = paste0("lifetable_rr_corrected"))

input_risk_paf <-
      bestcost::get_risk_and_paf(input = input)

lifetable_withPop <-
      bestcost::compile_lifetable_pop(
        first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...), # From age 0 onwards
        last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
        prob_natural_death_male = prob_dying[["total"]][["male"]]$prob_dying,
        prob_natural_death_female = prob_dying[["total"]][["female"]]$prob_dying,
        prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
        prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
        population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
        population_midyear_female =  airqplus_pm_deaths_yll[["pop"]]$midyear_population_female)

# pop_impact <-
#       bestcost::get_pop_impact(
#         lifetab_withPop = lifetable_withPop,
#         year_of_analysis = airqplus_pm_deaths_yll[["input"]]$start_year,
#         pop_fraction = input_risk_paf[, c("erf_ci", "paf")],
#         outcome_metric = "death")
# Here there's a NA for the last row --> investigate

# Assign variables for running the function code from "get_pop_impact" line by line
## Variables for running loop to calculate "popOverTime"
lifetab_withPop <- lifetable_withPop
year_of_analysis <- airqplus_pm_deaths_yll[["input"]]$start_year
pop_fraction <- input_risk_paf[, c("erf_ci", "paf")]
outcome_metric <- "death"
### NA introduced in first row in data frame "popOverTime" --> happens within function project_pop()

# Run function code of "project_pop_withExp" line by line
# s <- "female"
s <- "male"
v <- "central"
lifetab_withPop <- lifetab_withPop[[s]]
paf <- pop_fraction$paf[pop_fraction$erf_ci %in% v]
outcome_metric <- "death"

# Code from "project_pop()"
lifetab_withPop <-
      lifetab_withPop %>%
      dplyr::rename(!!paste0("population_", year_of_analysis) := population)

lifetable_withPop <- lifetab_withPop

second_year <- year_of_analysis + 1

# output_female <- lifetable_withPop %>%
#       dplyr::mutate(population_2020 =
#                       population_2019 * death_probability_natural * paf)

output_male <- lifetable_withPop %>%
      dplyr::mutate(population_2020 =
                      population_2019 * death_probability_natural * paf)
```

```{r round results and then sum, eval=FALSE, include=FALSE}
# bestcost_pm_deaths_lifetable_total <- data.frame(bestcost_pm_deaths_lifetable_total)
# names(bestcost_pm_deaths_lifetable_total) <- c("age_start", "age_end", "deaths")

bestcost_pm_deaths_lifetable_total <- bestcost_pm_deaths_lifetable_total %>% 
  mutate(deaths_rounded_0 = round(deaths, digits = 0),
         deaths_rounded_1 = round(deaths, digits = 1),
         deaths_rounded_2 = round(deaths, digits = 2),
         deaths_rounded_3 = round(deaths, digits = 3),
         deaths_rounded_4 = round(deaths, digits = 4),
         deaths_rounded_5 = round(deaths, digits = 5),
         deaths_rounded_6 = round(deaths, digits = 6)) %>% 
  relocate(deaths_rounded_0, .before = population_rounded_1)

sum <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths"])
sum_0 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_0"])
sum_1 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_1"])
sum_2 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_2"])
sum_3 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_3"])
sum_4 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_4"])
sum_5 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_5"])
sum_6 <- sum(bestcost_pm_deaths_lifetable_total[21:100, "deaths_rounded_6"])

```


```{r premature deaths with lifetable}
# Now with input data from the Swiss project GeLuft
bestcost_pm_deaths_lifetable_geluft <- 
    bestcost::attribute_deaths_lifetable_rr(

    exp_central = input_data_mortality$exp[2], # PM2.5=8.85 exp in CH in 2019
    cutoff = input_data_mortality$cutoff[2],   # PM2.5=5,i.e. WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"],
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = input_data_mortality$min_age[2])


check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_geluft ,
               result_vector_alternative = c(2610, 1378, 3815))



```



```{r premature deaths with lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    bestcost::attribute_deaths_lifetable_rr(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_geluft ,
               result_vector_alternative = c(2610, 1378, 3815)) # Result on 16 May 2024



```


#### Years of life lost

```{r yll with lifetable}

# Calculate years of life lost using bestcost function
# and input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  bestcost::attribute_yll_lifetable_rr(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

bestcost_pm_yll_lifetable_airqplus_new <-
  bestcost::attribute_yll_lifetable_rr_copy(
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    prob_natural_death_male = prob_dying[["natural"]][["male"]]$prob_dying,
    prob_natural_death_female = prob_dying[["natural"]][["female"]]$prob_dying,
    prob_total_death_male = prob_dying[["total"]][["male"]]$prob_dying,
    prob_total_death_female = prob_dying[["total"]][["female"]]$prob_dying,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# Check results
# They are extremely different. The methodology of airq+ is very different to other studies
# AirQ+ considers that the increase/decrease of exposure happens 100 years,
# while other studies (e.g. GeLuft) look at the impact over 100 years of a one-year exposure.
print("Original function")
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus,
               result_vector_alternative = 
                 c(airqplus_pm_deaths_yll[["output"]]$value_central_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_lower_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_upper_allgenders_yll_over_100_years_age_20_99))

print("Updated function")
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus_new,
               result_vector_alternative = c(airqplus_pm_deaths_yll[["output"]]$value_central_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_lower_allgenders_yll_over_100_years_age_20_99,
                   airqplus_pm_deaths_yll[["output"]]$value_upper_allgenders_yll_over_100_years_age_20_99))



# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_lifetable_geluft <- 
  bestcost::attribute_yll_lifetable_rr(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_geluft,
               result_vector_alternative = c(27742, 14641, 40542))

```


```{r yll lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    bestcost::attribute_yll_lifetable_rr(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               result_vector_alternative = c(27742))



```


```{r yll lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    bestcost::attribute_yll_lifetable_rr(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
      prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
      prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
      prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024

```

#### Years lived with disability

```{r morbidity yld lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_lifetable_rr(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    corrected_discount_rate = 0,
    # duration = 2, # Deactivate to test additional cases
    disability_weight = 1
  )


# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               result_vector_alternative = c(27742, 14641, 40542))


```

## Comparison

### Single bhd

```{r comparison singlebhd_rr}
# Test delta comparison function with fake values
# DELTA
comparison_singlebhd_rr_delta <-
  bestcost::compare_health_singlebhd_rr(
    comparison_method = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  bestcost::compare_health_singlebhd_rr(
    comparison_method = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024


```


```{r comparison ar}
# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  bestcost::compare_health_ar(
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    pop_exp_1 = c(387500, 286000, 191800, 72200, 7700), # Values as example provided by NIPH
    pop_exp_2 = c(387500, 286000, 191800, 72200, 7700), # Fake values
    erf_c_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022))

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024




```


```{r comparison deaths lifetable}

# DELTA

comparison_deaths_lifetable_delta <-
  bestcost::compare_deaths_lifetable_rr(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta ,
               result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["total"]]$impact_rounded) 


# PIF

comparison_deaths_lifetable_pif  <-
  bestcost::compare_deaths_lifetable_rr(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20)



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_deaths_lifetable_geluft[["total"]]$impact_rounded) 

```



```{r comparison yll lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  bestcost::compare_yll_lifetable_rr(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["total"]]$impact_rounded) 

# PIF
comparison_yll_lifetable_pif <-
  bestcost::compare_yll_lifetable_rr(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20)


# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               result_vector_alternative = c(20650,10870,30257)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["total"]]$impact_rounded)

```





```{r comparison yld lifetable}

# DELTA
 
comparison_yld_lifetable_delta  <-
  bestcost::compare_yld_lifetable_rr(
    comparison_method = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    #duration = 2,
    disability_weight = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               result_vector_alternative = c(20421,10806,29763)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["total"]]$impact_rounded) 

# PIF
comparison_yld_lifetable_pif <-
  bestcost::compare_yld_lifetable_rr(
    comparison_method = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    prob_natural_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_1 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_1 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    prob_natural_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male_2 = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female_2 = lifetable_withPopulation[["female"]]$death_probability_total,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    #duration = 2,
    disability_weight = 1)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               result_vector_alternative = c(20650,10870,30257)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["total"]]$impact_rounded)
```


```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  bestcost::compare_yld_singlebhd_rr(
    comparison_method = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["total"]]$impact_rounded) 

#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  bestcost::compare_yld_singlebhd_rr(
    comparison_method = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    disability_weight = 0.5,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")



# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that it produce the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["total"]]$impact_rounded) 


```

# Export 

```{r eval=FALSE, include=FALSE}
write.csv2(lifetable_airqplus,
            "../testing/output/lifetable_airqplus_2019_ch.csv", 
            row.names = FALSE)
```
