---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Test the functions of the bestcost package comparing the results with results from other tools or assessments


# Load packages and data


The R script required the loading of certain R packages. 
```{r Load packages and data, include=FALSE}

# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)
library(stats)

# to set colors in console messages (checking)
library(crayon)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)

## to make geo analysis
library(terra)
library(sf)

# Load healthiar package (either current version or installed version)
devtools::load_all(export_all = FALSE)

# Load data
load("../testing/input/data/input_data_for_testing_Rpackage.RData")

# Unit meeting demo
# data <- airqplus_pm_copd |> 
#   mutate(prevalence = incidents_per_100_000_per_year/1E5*population_at_risk)
```



```{r Alternative 1 to load healthiar: Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here: https://stackoverflow.com/a/71846333/6104907
if(!"healthiar" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT if prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/healthiar",
                           ref = "HEAD", # Branch name (by default "HEAD") as a string
                           force = TRUE)
}
library(healthiar)
```



```{r Alternative 2 to load healthiar: load zip from local source, eval=FALSE, include=FALSE}
detach("package:healthiar", unload = TRUE) # detach healthiar
# Package as .zip file
devtools::build(binary = TRUE, path = "../testing/input/") # Save current state of package as .zip file (e.g. to directly test changes in functions)
install.packages("../testing/input/healthiar_0.0.0.1.zip", repos=NULL, type='source') # Install package from source


# Package as .tar.gz file
devtools::build(path = "../testing/input/") # Save current state of package as tar.gz file (e.g. to directly test changes in functions)
install.packages("../testing/input/healthiar_0.0.0.1.tar.gz", repos=NULL, type='source') # Install package from source

library(healthiar)
```

# Test prepare function

```{r prepare_exposure_data, eval=FALSE, include=FALSE}

# To be added
# test <- prepare_exposure_data()

```

# Calculate health impacts

## Attributable health impact

### Single baseline health data


```{r Demo unit meeting}

# Calculate COPD cases attributable to PM exposure
# results_pm_copd <-
#   healthiar::attribute_health(
#     exp_central = data$mean_concentration,                      # 8.85
#     cutoff_central = data$cut_off_value,                        # 5
#     bhd_central = data$prevalence,                              # 30747
#     bhd_lower = data$prevalence - 1000,                         # 29747
#     bhd_upper = data$prevalence + 1000,                         # 31747
#     rr_central = data$relative_risk,                            # 1.36
#     rr_lower = data$relative_risk_lower,                        # 1.124
#     rr_upper = data$relative_risk_upper,                        # 1.664
#     erf_increment = 10,                                           
#     erf_shape = "log_linear", 
#     info = "pm_copd_assessment_1")

# Check results
# View(results_pm_copd)
# View(results_pm_copd$main)
# View(results_pm_copd$detailed$raw)


# Now with population
# results_pm_copd_pop <-
  # healthiar::attribute(
  #   exp_central = data$mean_concentration,                      # 8.85
  #   cutoff_central = data$cut_off_value,                        # 5
  #   bhd_central = data$prevalence,                              # 30747
  #   bhd_lower = data$prevalence - 1000,                         # 29747
  #   bhd_upper = data$prevalence + 1000,                         # 31747
  #   rr_central = data$relative_risk,                            # 1.36
  #   rr_lower = data$relative_risk_lower,                        # 1.124
  #   rr_upper = data$relative_risk_upper,                        # 1.664
  #   erf_increment = 10,                                           
  #   erf_shape = "log_linear", 
  #   info = "pm_copd_assessment_1",
  #   population = 1E6)
```



```{r Screenshot for poster, eval=FALSE, include=FALSE}

health_impact <- attribute(
    exp_central = 12.3,
    bhd_central = 15000,
    rr_central = 1.04,
    rr_lower = 1.02,
    rr_upper = 1.06,
    cutoff_central = 5,
    erf_shape = "log_linear",
    info = "scenario_1")

health_impact <- attribute(
    exposure = 12.3,
    baseline_health_data = 15000,
    rr_central = 1.04,
    cutoff = 5,
    erf_shape = "log_linear",
    info = "PM2.5_scenario_1")

```



```{r single exposure value}
# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_copd)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result <- 
                 # Store the central, lower and upper estimate of the AirQ+ assessment
                 airqplus_pm_copd |>
                 dplyr::select(estimated_number_of_attributable_cases_central,
                               estimated_number_of_attributable_cases_lower,
                               estimated_number_of_attributable_cases_upper)|>
                 unlist())
```






```{r single exposure value with multiple uncertainties}

# Assess attributable cases for multiple uncertainties at the same time
# i.e. rr, bhd and exp
bestcost_pm_copd_multiple <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    exp_lower = 8,
    exp_upper = 9,
    cutoff_central = airqplus_pm_copd$cut_off_value, 
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = 25000,
    bhd_upper = 35000,
    rr_central = airqplus_pm_copd$relative_risk, 
    rr_lower = airqplus_pm_copd$relative_risk_lower,
    rr_upper = airqplus_pm_copd$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_copd_multiple)
check_bestcost(result_list_bestcost = bestcost_pm_copd_multiple,
               result_vector_alternative = c(3502, 1353, 5474)) # Results on 5 November 2024



# Assess iteration geographical sections keeping the multiple uncertainties
system.time(
  bestcost_pm_copd_geo <-
    healthiar::attribute_health(
      exp_central = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
      exp_lower = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
      exp_upper = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
      cutoff_central = 5,   
      bhd_central = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      # bhd_lower = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      bhd_lower = as.list(runif_with_seed(1E4, 20000, 30000, 1)),
      # bhd_upper = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
      bhd_upper = 0,
      rr_central = 1.369, 
      rr_lower = 1.124,
      rr_upper = 1.664,
      erf_increment = 10, 
      erf_shape = "log_linear", 
      population = as.list(rep(1E6, 1E4)),
      geo_id_raw = 1:1E4, 
      geo_id_aggregated = rep("CH", 1E4),
      info = "PM2.5_copd")
  )

# View(bestcost_pm_copd_geo)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo,
               result_vector_alternative = c(31460722, 12120764, 49312859)) # Results on 5 November 2024

# Assess iteration geographical sections keeping the multiple uncertainties
system.time(bestcost_pm_copd_geo_short <-
  healthiar::attribute_health(
    exp_central = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)+0.1),
    cutoff_central = 5,   
    bhd_central = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    bhd_lower = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    bhd_upper = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E1, 
    geo_id_aggregated = rep("CH", 1E1),
    info = "PM2.5_copd"))

# View(bestcost_pm_copd_geo_short)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo_short,
               result_vector_alternative = c(32449, 12508, 50836)) # Results on 5 November 2024
```





```{r Social aspects in a simple case}
# Take into account social aspects

# First calculate attributable deahts based on total mortality as provide by Sciensano
bestcost_pm_death <- 
  healthiar::attribute_health(
    exp_central = as.list(social_data$PM25_MEAN),
    cutoff_central = 0,
    rr_central = 1.08, # The data set contains the RR for the exposure but not per increment. Calculable as e.g. exp(log(1.038017)/(4.848199)*10) 
    erf_shape = "log_linear", 
    erf_increment = 10,
    bhd_central = as.list(social_data$MORTALITY_TOTAL),
    population = social_data$POPULATION,
    geo_id_raw = social_data$CS01012020)

# Then include social indicators of deprivation 
bestcost_pm_death_social_decile <- 
  healthiar::include_social(output = bestcost_pm_death,
                            geo_id_raw = social_data$CS01012020,
                            deprivation_score = social_data$score,
                            n_quantile = 10,
                            approach = "quantile")


# Check that results did not change over time
check_general(
  a = bestcost_pm_death_social_decile[["social_main"]]$difference_value,
  # Results on 21 Nov 2024
  b = c(22.52416423, 0.32236823, 14.5680866,0.17252793))

```


```{r single exposure & user-defined points for relative risk using splinefun}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_alri_erf_dots_splinefun <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    # cutoff_central = 0,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    # GBD2019 ERF for PM and lower respiratory infections
    erf_eq_central = 
      stats::splinefun(
        x = c(600,500,400,300,200,150,130,110,90,70,50,30,25,20,15,10,5,0),
        y = c(2.189,2.143,2.098,2.052,1.909,1.751,1.68,1.607,1.533,1.453,1.357,1.238,1.204,1.168,1.129,1.089,1.046,	1),
        method = "natural"),
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_alri_erf_dots_splinefun)

# check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_splinefun,
#                result_vector_alternative = c(2263)) # Results on 10 October 2024 (with cutoff = 0)
check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_splinefun,
               result_vector_alternative = c(1057)) # Results on 10 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value)
```

```{r single exposure & user-defined points for relative risk using approxfun}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_alri_erf_dots_approxfun <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    # cutoff_central = 0,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    # GBD2019 ERF for PM and lower respiratory infections
    erf_eq_central = 
      stats::approxfun(
        x = c(600,500,400,300,200,150,130,110,90,70,50,30,25,20,15,10,5,0),
        y = c(2.189,2.143,2.098,2.052,1.909,1.751,1.68,1.607,1.533,1.453,1.357,1.238,1.204,1.168,1.129,1.089,1.046,	1),
        method = "linear"),
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# View(bestcost_pm_alri_erf_dots_approxfun)

# check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_approxfun,
#                result_vector_alternative = c(2254)) # Results on 10 October 2024 (with cutoff = 0)
check_bestcost(result_list_bestcost = bestcost_pm_alri_erf_dots_approxfun,
               result_vector_alternative = c(1052)) # Results on 10 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value)
```



```{r single exposure value and relative risk with monetization}

# Assess attributable cases using the AirQ+ export as input data
bestcost_pm_copd_1rr <-
  healthiar::attribute_health(
    exp_central = airqplus_pm_copd$mean_concentration,
    cutoff_central = airqplus_pm_copd$cut_off_value,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    rr_central = airqplus_pm_copd$relative_risk,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info = paste0(airqplus_pm_copd$pollutant,"_", airqplus_pm_copd$evaluation_name))

# Store the central, lower and upper estimate of the AirQ+ assessment
airqplus_pm_copd_1rr_result <- 
  airqplus_pm_copd |>
  dplyr::select(estimated_number_of_attributable_cases_central)|>
  unlist()

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_copd,
               result_vector_alternative = airqplus_pm_copd_result)
```


```{r exposure distribution with rr}

# Extract rows that contain input data (others may contain results)
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ihd_result <- 
  niph_noise_ihd_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(daly)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  healthiar::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    # exp_lower = niph_noise_ihd_input$exposure_mean - 2,
    # exp_upper = niph_noise_ihd_input$exposure_mean + 2,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    # rr_lower = 1.08 - 0.02,
    # rr_upper = 1.08 + 0.02,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))

# View(bestcost_noise_ihd_expDist)

check_bestcost(result_list_bestcost = bestcost_noise_ihd_expDist,
               result_vector_alternative = niph_noise_ihd_result)

 
# Obtain attributable cases using the bestcost package
# for multiple geo_sections
bestcost_noise_ihd_expDist_geo <- 
  healthiar::attribute_health(
    exp_central = list(runif_with_seed(5,8,10,1), 
                       runif_with_seed(5,8,10,2), 
                       runif_with_seed(5,8,10,3)),
    cutoff_central = 5,
    prop_pop_exp = list(runif_with_seed(5,0.1,1,1),
                        runif_with_seed(5,0.1,1,2), 
                        runif_with_seed(5,0.1,1,3)),
    bhd_central = list(runif_with_seed(3,1E4,1E5,1)),
    rr_central = 1.08,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3,
    geo_id_aggregated = rep("ch", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

# View(bestcost_noise_ihd_expDist_geo)
```

```{r exposure distribution and user-defined points for relative risk}
MRBRT_stroke <- readRDS(file = "../testing/input/MRBRT_stroke.RDS")
pop_data <- readRDS(file = "../testing/input/pop_data.RDS")

bestcost_pm_stroke_mr_brt <-
  healthiar::attribute_health(
    exp_central = pop_data$Concentration,
    prop_pop_exp = pop_data$Viken,
    cutoff_central = 5,
    # cutoff_central = 0,
    bhd_central = 4500,
    erf_eq_central = 
      stats::splinefun(
        x = MRBRT_stroke$exposure,
        y = MRBRT_stroke$mean,
        method = "natural"))

# View(bestcost_pm_stroke_niph)
# print(bestcost_pm_stroke_niph$main[, c("pop_fraction", "impact_rounded")])

# View(bestcost_pm_stroke_mr_brt)

# check_bestcost(result_list_bestcost = bestcost_pm_stroke_mr_brt,
#                result_vector_alternative = c(249)) # Results on 17 October 2024 (with cutoff = 0)
check_bestcost(result_list_bestcost = bestcost_pm_stroke_mr_brt,
               result_vector_alternative = c(32)) # Results on 17 October 2024 (with cutoff = 5 = airqplus_pm_copd$cut_off_value)
```



```{r absolute risk}

# Extract rows that contain input data (others may contain results)
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Extract results from excel table
# Only one (central) value for ERF, 
# so let's repeat the value three times to build 
# the vector for lower and upper bound
niph_noise_ha_result <- 
  niph_noise_ha_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(number)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ha_ar <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    # exp_lower = niph_noise_ha_input$exposure_mean - 1,
    # exp_upper = niph_noise_ha_input$exposure_mean + 1
    population = sum(niph_noise_ha_input$population_exposed_total), 
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

# View(bestcost_noise_ha_ar)

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result)

# YLD case for absolute risk
bestcost_noise_ha_ar <- 
  healthiar::attribute_yld(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    population = sum(niph_noise_ha_input$population_exposed_total), 
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10,
    duration_central = 1, duration_lower = 0.1, duration_upper = 10,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

check_bestcost(result_list_bestcost = bestcost_noise_ha_ar,
               result_vector_alternative = niph_noise_ha_result/2)

# Obtain attributable cases using the bestcost package and input data from niph
# for multiple geo_sections
bestcost_noise_ha_ar_geo <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = list(runif_with_seed(5,8,10,1), 
                          runif_with_seed(5,8,10,2), 
                          runif_with_seed(5,8,10,3)),
    population = list(runif_with_seed(1,5E3,1E4,1),
                        runif_with_seed(1,5E3,1E4,2), 
                        runif_with_seed(1,5E3,1E4,3)),
    prop_pop_exp = list(runif_with_seed(5,0,1,1),
                        runif_with_seed(5,0,1,2), 
                        runif_with_seed(5,0,1,3)), 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3,
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"))

```


```{r YLD with single relative risk}

bestcost_pm_yld_singlebhd  <- 
  healthiar::attribute_yld(
    exp_central = 8.85, 
    cutoff_central = 5,    
    bhd_central = 25000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5, dw_lower = 0.1, dw_upper = 10,
    duration_central = 1, duration_lower = 0.5, duration_upper = 10)

# View(bestcost_pm_yld_singlebhd)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yld_singlebhd ,
               result_vector_alternative = c(525, 277, 768)) # Result on 16 May 2024
```

### Summary uncertainty

```{r Summary uncertainty rr single exposure attribute_health }

bestcost_pm_copd_with_summary_uncertainty <- 
  healthiar::attribute_health(
    exp_central = 8.85, 
    exp_lower = airqplus_pm_copd$mean_concentration - 1,
    exp_upper = airqplus_pm_copd$mean_concentration + 1,
    cutoff_central = 5,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) - 5000,
    bhd_upper = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) + 5000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear"
    )

# View(bestcost_pm_copd_with_summary_uncertainty)

bestcost_pm_copd_extern_uncertainty <-
  healthiar::include_summary_uncertainty(
    res = bestcost_pm_copd_with_summary_uncertainty,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
## Central estimates
print("Main estimates: ") ; bestcost_pm_copd_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
## With external uncertainty function (i.e. include_summary_uncertainty())
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_pm_copd_extern_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results of internal Monte-Carlo summary uncertainty and extern Monte-Carlo summary uncertainty identical!
```

```{r Summary uncertainty rr single exposure iteration}

# Assess iteration geographical sections keeping the multiple uncertainties
bestcost_pm_copd_geo_short <-
  healthiar::attribute_health(
    exp_central = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)),
    exp_lower = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)-0.1),
    exp_upper = as.list(runif_with_seed(1E1, 8.0, 9.0, 1)+0.1),
    cutoff_central = 5,
    # cutoff_lower = 4,
    # cutoff_upper = 6,
    bhd_central = as.list(runif_with_seed(1E1, 25000, 35000, 1)),
    # bhd_lower = as.list(runif_with_seed(1E1, 20000, 30000, 1)),
    # bhd_upper = as.list(runif_with_seed(1E1, 30000, 40000, 1)) ,
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E1, 
    geo_id_aggregated = rep("CH", 1E1),
    info = "PM2.5_copd")

# View(bestcost_pm_copd_geo_short)
check_bestcost(result_list_bestcost = bestcost_pm_copd_geo_short,
               result_vector_alternative = c(32449, 12508, 50836)) # Results on 5 November 2024

bestcost_pm_copd_geo_short_uncertainty <- 
  healthiar::include_summary_uncertainty(
    bestcost_pm_copd_geo_short,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ") ; bestcost_pm_copd_geo_short[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_pm_copd_geo_short_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results seem plausible
```



```{r Summary uncertainty rr & exposure distribution}

# Data prep
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))
niph_noise_ihd_result <- 
  niph_noise_ihd_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(daly)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist <- 
  healthiar::attribute_health(
    exp_central = niph_noise_ihd_input$exposure_mean,
    # exp_lower = niph_noise_ihd_input$exposure_mean - 2,
    # exp_upper = niph_noise_ihd_input$exposure_mean + 2,
    prop_pop_exp = niph_noise_ihd_input$prop_exposed,
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = niph_noise_ihd_input$gbd_daly[1],
    rr_central = 1.08,
    rr_lower = 1.08 - 0.02,
    rr_upper = 1.08 + 0.02,
    erf_increment = 10, 
    erf_shape = "log_linear",
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))

# View(bestcost_noise_ihd_expDist)

# Calculate summary uncertainty
bestcost_noise_ihd_expDist_extern_uncertainty <- include_summary_uncertainty(
  bestcost_noise_ihd_expDist,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ") ; bestcost_noise_ihd_expDist[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ihd_expDist_extern_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results seem plausible
```



```{r Summary uncertainty rr exposure distribution iteration}
# Data prep
niph_noise_ihd_input <- 
  niph_noise_ihd_excel |>
  dplyr::filter(!is.na(niph_noise_ihd_excel$exposure_mean))
niph_noise_ihd_result <- 
  niph_noise_ihd_excel |>
        dplyr::filter(exposure_category %in% "Total exposed")|>
        dplyr::select(daly)|>
        dplyr::pull() |>
  round()

# Obtain attributable cases using the bestcost package and input data from niph
bestcost_noise_ihd_expDist_iteration <- 
  healthiar::attribute_health(
    exp_central = list(niph_noise_ihd_input$exposure_mean,
                       niph_noise_ihd_input$exposure_mean + 5,
                       niph_noise_ihd_input$exposure_mean + 10),
    exp_lower = list(niph_noise_ihd_input$exposure_mean - 2,
                     niph_noise_ihd_input$exposure_mean + 5 - 2,
                     niph_noise_ihd_input$exposure_mean + 10 - 2),
    exp_upper = list(niph_noise_ihd_input$exposure_mean + 2,
                     niph_noise_ihd_input$exposure_mean + 5 + 2,
                     niph_noise_ihd_input$exposure_mean + 10 + 2),
    prop_pop_exp = list(niph_noise_ihd_input$prop_exposed,
                        niph_noise_ihd_input$prop_exposed + 0.1,
                        niph_noise_ihd_input$prop_exposed + 0.2),
    cutoff_central = min(niph_noise_ihd_input$exposure_mean), 
    bhd_central = list(niph_noise_ihd_input$gbd_daly[1], 
                       niph_noise_ihd_input$gbd_daly[1] + 5000,
                       niph_noise_ihd_input$gbd_daly[1] + 10000),
    rr_central = 1.08,
    # rr_lower = 1.08 - 0.02,
    # rr_upper = 1.08 + 0.02,
    erf_increment = 10, 
    erf_shape = "log_linear",
    geo_id_raw = 1:3, 
    geo_id_aggregated = rep("CH", 3),
    info = data.frame(pollutant = "road_noise", outcome = "YLD"))
# View(bestcost_noise_ihd_expDist_iteration)

bestcost_noise_ihd_expDist_iteration_uncertainty <- include_summary_uncertainty(
  bestcost_noise_ihd_expDist_iteration,
    n_sim = 100)
# View(bestcost_noise_ihd_expDist_iteration_uncertainty)
# Results are higher due to difference in PAF of categories 2 & 3

# Check impacts per geo unit
## Central estimates from attribte()
round(as.numeric(bestcost_noise_ihd_expDist_iteration[["health_detailed"]][["raw"]] |> filter(erf_ci == "central") |> filter(exp_ci == "central") |> pull(impact_rounded)), digits = 0) 
## Summary uncertainty estimates from include_summary_uncertainty()
round(as.numeric(bestcost_noise_ihd_expDist_iteration_uncertainty[["uncertainty"]][["health_detailed"]][["geo_specific"]]$impact_central), digits = 0)
# Results are higher due to difference in PAF of categories 2 & 3

# Check aggregated impact
print("Main estimate: ") ; bestcost_noise_ihd_expDist_iteration[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ihd_expDist_iteration_uncertainty[["uncertainty_main"]] |> pull(central_estimate)), digits = 0)
# Aggregated results are higher due to difference in PAF of categories 2 & 3
```



```{r Summary uncertainty rr attribute_yld}

bestcost_pm_yld_singlebhd_with_summary_uncertainty  <- 
  healthiar::attribute_yld(
    exp_central = 8.85, 
    exp_lower = airqplus_pm_copd$mean_concentration - 1,
    exp_upper = airqplus_pm_copd$mean_concentration + 1,
    cutoff_central = 5,
    cutoff_lower = airqplus_pm_copd$cut_off_value - 1,
    cutoff_upper = airqplus_pm_copd$cut_off_value + 1,
    bhd_central = airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk,
    bhd_lower = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) - 5000,
    bhd_upper = (airqplus_pm_copd$incidents_per_100_000_per_year/1E5*airqplus_pm_copd$population_at_risk) + 5000,
    rr_central = 1.118,
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    # dw_central = 0.9, dw_lower = 0.88, dw_upper = 0.93,
    dw_central = 0.5, dw_lower = 0.25, dw_upper = 0.75,
    duration_central = 1
    )

bestcost_pm_yld_singlebhd_external_summary_uncertainty <- healthiar::include_summary_uncertainty(
  bestcost_pm_yld_singlebhd_with_summary_uncertainty,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_pm_yld_singlebhd_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_pm_yld_singlebhd_external_summary_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar}

# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_with_summary_uncertainty <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = niph_noise_ha_input$exposure_mean,
    exp_lower = niph_noise_ha_input$exposure_mean - 1,
    exp_upper = niph_noise_ha_input$exposure_mean + 1,
    population = sum(niph_noise_ha_input$population_exposed_total),
    prop_pop_exp = niph_noise_ha_input$population_exposed_total/sum(niph_noise_ha_input$population_exposed_total), 
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance")
    )
# View(bestcost_noise_ha_ar_with_summary_uncertainty)

bestcost_noise_ha_ar_external_uncertainty <- healthiar::include_summary_uncertainty(
  bestcost_noise_ha_ar_with_summary_uncertainty,
  n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
print("Main estimate: ")
bestcost_noise_ha_ar_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
# External include_summary_uncertainty function
print("Summary uncertainty estimates (extern uncertainty function): ")
round(as.numeric(bestcost_noise_ha_ar_external_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results seem plausible
```

```{r Summary uncertainty ar iteration}

# Get data
niph_noise_ha_input <- 
  niph_noise_ha_excel |>
  dplyr::filter(!is.na(niph_noise_ha_excel$exposure_mean))

# Internal get_ci function
bestcost_noise_ha_ar_iteration <- 
  healthiar::attribute_health(
    approach_risk = "absolute_risk",
    exp_central = list(niph_noise_ha_input$exposure_mean,
                       niph_noise_ha_input$exposure_mean + 5,
                       niph_noise_ha_input$exposure_mean + 10),
    exp_lower = list(niph_noise_ha_input$exposure_mean -2,
                       niph_noise_ha_input$exposure_mean + 5 - 2,
                       niph_noise_ha_input$exposure_mean + 10 - 2),
    exp_upper = list(niph_noise_ha_input$exposure_mean + 2,
                       niph_noise_ha_input$exposure_mean + 5 + 2,
                       niph_noise_ha_input$exposure_mean + 10 + 2),
    prop_pop_exp = list(niph_noise_ha_input$population_exposed_total, 
                   niph_noise_ha_input$population_exposed_total + 0.1,
                   niph_noise_ha_input$population_exposed_total + 0.2),
    population = list(runif_with_seed(1,5E3,1E4,1),
                        runif_with_seed(1,5E3,1E4,2), 
                        runif_with_seed(1,5E3,1E4,3)),
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    geo_id_raw = 1:3, 
    geo_id_aggregated = rep("CH", 3),
    info = data.frame(pollutant = "road_noise", outcome = "highly_annoyance"),
    )
# View(bestcost_noise_ha_ar_with_summary_uncertainty)

bestcost_noise_ha_ar_iteration_with_summary_uncertainty <-
  healthiar::include_summary_uncertainty(
    res = bestcost_noise_ha_ar_iteration,
    n_sim = 100)

# Comparison central +- 95% CIs & Monte-Carlo central, lower, upper estimates
# View(bestcost_pm_yld_singlebhd_with_summary_uncertainty)
print("Main estimates: ") ; bestcost_noise_ha_ar_iteration_with_summary_uncertainty[["health_main"]][["impact_rounded"]]
print("Summary uncertainty estimates (external function): ")
round(as.numeric(bestcost_noise_ha_ar_iteration_with_summary_uncertainty[["uncertainty"]][["health_main"]]), digits = 0)
# Results seem plausible
```



### Multiple exposure

```{r additive approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_additive <-
  healthiar::attribute_health(
    approach_multiexposure = "additive",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    erf_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_additive,
               result_vector_alternative = 0.081 * 1000)
```


```{r multiplicative approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_multiplicative <-
  healthiar::attribute_health(
    approach_multiexposure = "multiplicative",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    erf_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative,
               result_vector_alternative = 0.079 * 1000)
```


```{r combined approach}
# Assess attributable cases using the BEST-COST task 1.4 report
bestcost_pm_no2_mortality_multiplicative <-
  healthiar::attribute_health(
    approach_multiexposure = "combined",
    exp_central = c("pm2.5" = 8.1, "no2" =  10.9),
    cutoff_central =  setNames(c(0, 0), c("pm2.5", "no2")),
    bhd_central = 1000, # Fake data just to get a similar value (PAF) as in the T1.4 report
    rr_central = setNames(c(1.063, 1.031), c("pm2.5", "no2")),
    erf_increment = setNames(c(10, 10), c("pm2.5", "no2")), 
    erf_shape = "log_linear")

# View(bestcost_pm_copd_1rr)

check_bestcost(result_list_bestcost = bestcost_pm_no2_mortality_multiplicative,
               result_vector_alternative = 0.079 * 1000)
```


### Life table

#### Premature deaths

```{r premature deaths lifetable airqplus input}

# Calculate premature deaths using bestcost function
# and input data from an AirQ+ case

bestcost_pm_deaths_lifetable_airqplus <-
  healthiar::attribute_deaths_from_lifetable(
    approach_exposure = "single_year",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration, 
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female, 
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# View(bestcost_pm_deaths_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_airqplus,
                result_vector_alternative = c(2600.9, 1371, 3804))
```



```{r premature deaths lifetable and exposure distribution}

# Calculate premature deaths using bestcost function
bestcost_pm_deaths_lifetable_expDistribution <- 
    healthiar::attribute_deaths_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff_central = input_data_mortality$cutoff[2],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
      rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
      rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
      rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = 20)

# View(bestcost_pm_deaths_lifetable_expDistribution)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_deaths_lifetable_expDistribution,
               result_vector_alternative = c(2900, 1531, 4239)) # Result on 20 August 2024
```



#### Years of life lost (YLL)

```{r YLL lifetable from SINGLE YEAR exposure}

# Now with input data from the Swiss project GeLuft
bestcost_pm_yll_exposure_single_year_lifetable_geluft <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "single_year",
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff_central = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

check_bestcost(result_list_bestcost = bestcost_pm_yll_exposure_single_year_lifetable_geluft,
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result


# Now with input data from the Swiss project GeLuft and discounted
bestcost_pm_yll_exposure_single_year_lifetable_geluft_discounted <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "single_year",
    exp_central = input_data_mortality$exp[2], #exp CH 2019
    prop_pop_exp = 1,
    cutoff_central = input_data_mortality$cutoff[2], # WHO AQG 2021 
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population, 
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2], 
    min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2],
    discount_shape = "exponential", 
    #Alternatives: "exponential", "hyperbolic_harvey_1986" "hyperbolic_mazur_1987",
    corrected_discount_rate = 0.01)

check_bestcost(result_list_bestcost = bestcost_pm_yll_exposure_single_year_lifetable_geluft_discounted,
               result_vector_alternative = c(26493, 13877, 39006)) # Results obtained on 5 Dec 2024

```



```{r YLL lifetable from CONSTANT exposure and NO NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "without_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# View(bestcost_pm_yll_lifetable_airqplus)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus,
               result_vector_alternative = c(2776839.17,	1452410.83,	4094163.08)) # AirQ+ result
```



```{r YLL lifetable from CONSTANT exposure and WITH NEWBORNS}

# Input data from an AirQ+ case

bestcost_pm_yll_lifetable_airqplus_with_newborns <-
  healthiar::attribute_yll_from_lifetable(
    approach_exposure = "constant",
    approach_newborns = "with_newborns",
    exp_central = airqplus_pm_deaths_yll[["input"]]$mean_concentration,
    cutoff_central = airqplus_pm_deaths_yll[["input"]]$cut_off_value,
    rr_central = airqplus_pm_deaths_yll[["input"]]$relative_risk,
    rr_lower = airqplus_pm_deaths_yll[["input"]]$relative_risk_lower,
    rr_upper = airqplus_pm_deaths_yll[["input"]]$relative_risk_upper,
    erf_increment = 10, 
    erf_shape = gsub("-", "_", airqplus_pm_deaths_yll[["input"]]$calculation_method),
    first_age_pop = first(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    last_age_pop = last(airqplus_pm_deaths_yll[["pop"]]$age_from...),
    population_midyear_male = airqplus_pm_deaths_yll[["pop"]]$midyear_population_male,
    population_midyear_female = airqplus_pm_deaths_yll[["pop"]]$midyear_population_female,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    year_of_analysis =  airqplus_pm_deaths_yll[["input"]]$start_year, 
    min_age = airqplus_pm_deaths_yll[["input"]]$apply_rr_from_age)

# View(bestcost_pm_yll_lifetable_airqplus_with_newborns)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_airqplus_with_newborns,
               result_vector_alternative = c(3248408.53,	1700230.04,	4786195.41)) # AirQ+ result
```



```{r YLL lifetable with single relative risk}
# Only one relative risk estimate (central estimate)

# Calculate years of life lost using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yll_lifetable_1rr_geluft <- 
    healthiar::attribute_yll_from_lifetable(
      exp_central = input_data_mortality$exp[2], #exp CH 2019
      prop_pop_exp = 1,
      cutoff_central = input_data_mortality$cutoff[2], 
      rr_central = input_data_mortality[2,"rr_central"], 
      erf_increment = 10, 
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

# View(bestcost_pm_yll_lifetable_1rr_geluft)

check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_1rr_geluft,
               # result_vector_alternative = c(27742)) # GeLuft approach result 
               result_vector_alternative = c(29274.89)) # AirQ+ approach result 
```



```{r YLL lifetable with exposure distribution}

# Calculate years of life lost using bestcost function
# with exposure distribution (instead of population-weighted mean)

bestcost_pm_yll_lifetable_expDistribution_geluft <- 
    healthiar::attribute_yll_from_lifetable(
      exp_central = c(8, 9, 10), # Fake data just for testing purposes
      prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
      cutoff_central = input_data_mortality$cutoff[2], # WHO AQG 2021 
      rr_central = input_data_mortality[2,"rr_central"], 
      rr_lower = input_data_mortality[2,"rr_lower"], 
      rr_upper =input_data_mortality[2,"rr_upper"], 
      erf_increment = 10,
      erf_shape = "log_linear",
      first_age_pop = 0,
      last_age_pop = 99,
      deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
      deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
      population_midyear_male = lifetable_withPopulation[["male"]]$population, 
      population_midyear_female = lifetable_withPopulation[["female"]]$population, 
      year_of_analysis = 2019, 
      info = input_data_mortality$pollutant[2], 
      min_age = if(is.na(input_data_mortality$min_age[2])) NULL else input_data_mortality$min_age[2])

# View(bestcost_pm_yll_lifetable_expDistribution_geluft)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = bestcost_pm_yll_lifetable_expDistribution_geluft ,
               # result_vector_alternative = c(30931, 16337, 45166)) # Result on 16 May 2024 (GeLuft approach)
               result_vector_alternative = c(32704, 17122, 48173)) # Result on 20 August 2024 (AirQ+ approach)

```



#### Years lived with disability (YLD)

```{r YLD lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_yld_lifetable_geluft  <- 
  attribute_yld_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    # exp_central = c(8, 9, 10), # Fake data. Deactivate to test exposure distribution.
    prop_pop_exp = 1,
    # prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data. Deactivate to test exposure distribution.
    cutoff_central = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper = input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure = "single_year",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration_central = 100, 
    duration_lower = 50, duration_upper = 100, 
    corrected_discount_rate = 0,
    dw_central = 1 #, dw_lower = 0.1, dw_upper = 10
)

# View(bestcost_pm_yld_lifetable_geluft)

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
check_bestcost(result_list_bestcost = bestcost_pm_yld_lifetable_geluft,
               # result_vector_alternative = c(27742, 14641, 40542)) # GeLuft approach result
               result_vector_alternative = c(29274.89,	15328.16,	43118.30)) # AirQ+ approach result

```



#### Disability-adjusted lived years (DALY)

```{r DALY lifetable}

# Calculate years lived with disability using bestcost function
# with input data from the Swiss project GeLuft

bestcost_pm_daly_lifetable_geluft  <- 
  attribute_daly_from_lifetable(
    exp_central = input_data_mortality$exp[2],
    prop_pop_exp = 1,
    cutoff_central = input_data_mortality$cutoff[2],
    rr_central = input_data_mortality[2,"rr_central"], 
    rr_lower = input_data_mortality[2,"rr_lower"], 
    rr_upper =input_data_mortality[2,"rr_upper"], 
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop = 0,
    last_age_pop = 99,
    deaths_male = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female = lifetable_withPopulation[["female"]]$population,
    year_of_analysis = 2019, 
    info = input_data_mortality$pollutant[2],
    min_age = input_data_mortality$min_age[2], # min_age = 20,
    duration_central = 100, 
    dw_central = 1)

# The Swiss project GeLuft did not calculated the YLD, only YLL. 
# But disability weight = 1 in the function above, then YLD = YLL 
# and the result should be identical.
# Since DALY = YLL + YLD and in this case YLL=YLD --> DALY = 2*YLL
check_bestcost(result_list_bestcost = bestcost_pm_daly_lifetable_geluft,
               # result_vector_alternative = c(27742*2, 14641*2, 40542*2)) # GeLuft approach result
               result_vector_alternative = c(29274.89*2,	15328.16*2,	43118.30*2)) # AirQ+ approach result


```



## Comparison

### Single bhd

```{r comparison singlebhd_rr}



# Test delta comparison function with fake values
# DELTA

comparison_singlebhd_rr_delta <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta ,
               result_vector_alternative = c(774, 409, 1127)) # Result on 16 May 2024


# With same impact to test that there is no error.
comparison_singlebhd_rr_delta_same_impact <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 8.85,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_same_impact ,
               result_vector_alternative = c(0, 0, 0)) # Result on 27 Nov 2024

# With iteration
comparison_singlebhd_rr_delta_geo <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(1100, 582, 1603)) # Result on 26 June 2024

#PIF
# Test pif comparison function with fake values
comparison_singlebhd_rr_pif <-
  healthiar::compare(
    approach_comparison = "pif",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif ,
               result_vector_alternative = c(782, 412, 1146)) # Result on 16 May 2024

# With iteration
comparison_singlebhd_rr_pif_geo <-
  healthiar::compare_health(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = list(25000, 20000),
    bhd_central_2 = list(25000, 20000),
    rr_central = 1.118, 
    rr_lower = 1.060, 
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(1114, 586, 1634)) # Result on 19 June 2024
```


```{r comparison singlebhd_rr geo iteration, eval=FALSE, include=FALSE}
# Assess iteration in many geographical areas (geo_id) keeping the multiple uncertainties
comparison_singlebhd_rr_geo <-
  healthiar::compare_health(
    approach_comparison = "delta",
    exp_central_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)),
    exp_lower_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)-0.1),
    exp_upper_1 = as.list(runif_with_seed(1E4, 8.0, 9.0, 1)+0.1),
    exp_central_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)),
    exp_lower_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)-0.1),
    exp_upper_2 = as.list(runif_with_seed(1E4, 8.0, 9.0, 2)+0.1),
    cutoff_central = 5,   
    bhd_central_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_1 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_central_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_lower_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    bhd_upper_2 = as.list(runif_with_seed(1E4, 25000, 35000, 1)),
    rr_central = 1.369, 
    rr_lower = 1.124,
    rr_upper = 1.664,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    geo_id_raw = 1:1E4, 
    geo_id_aggregated = rep("CH", 1E4),
    info_1 = "PM2.5_mortality_2010",
    info_2 = "PM2.5_mortality_2020")

# View(comparison_singlebhd_rr_geo)
```


```{r comparison ar}

# Test delta comparison function with fake values
# No PIF option in ar
comparison_singlebhd_ar_delta <-
  healthiar::compare_health(
    approach_risk = "absolute_risk",
    approach_comparison = "delta",
    exp_central_1 = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    exp_central_2 = c(50, 55, 60, 65, 75), # Fake values
    population_1 = sum(c(387500, 286000, 191800, 72200, 7700)),
    population_2 = sum(c(387500, 286000, 191800, 72200, 7700)),
    prop_pop_exp_1 = c(387500, 286000, 191800, 72200, 7700)/sum(c(387500, 286000, 191800, 72200, 7700)), # Values as example provided by NIPH
    prop_pop_exp_2 = c(387500, 286000, 191800, 72200, 7700)/sum(c(387500, 286000, 191800, 72200, 7700)), # Fake values
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022)
    )

# View(comparison_singlebhd_ar_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta ,
               result_vector_alternative = c(62531)) # Result on 23 May 2024

comparison_singlebhd_ar_delta_geo <-
  healthiar::compare_health(
    approach_risk = "absolute_risk",
    approach_comparison = "delta",
    exp_central_1 = list(c(57.5, 62.5, 67.5, 72.5, 77.5), c(57, 62, 67, 72, 77)),# Fake values
    exp_central_2 = list(c(50, 55, 60, 65, 75), c(50.5, 55.5, 60.5, 65.5, 75.5)), # Fake values
    population_1 = list(945200, 929800),
    population_2 = list(945200, 929800),
    prop_pop_exp_1 = list(c(387500, 286000, 191800, 72200, 7700)/945200, 
                          c(380000, 280000, 190800, 72000, 7000)/929800), # Fake values
    prop_pop_exp_2 = list(c(387500, 286000, 191800, 72200, 7700)/945200, 
                          c(380000, 280000, 190800, 72000, 7000)/929800), # Fake values
    erf_eq_central = "78.9270-3.1162*c+0.0342*c^2",
    info_1 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2020),
    info_2 = data.frame(pollutant = "road_noise", outcome = "highly_annoyance", year = 2022),
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_singlebhd_ar_delta_geo)

check_bestcost(result_list_bestcost = comparison_singlebhd_ar_delta_geo ,
               result_vector_alternative = 115869) # Result on 19 June 2024

```

```{r comparison yld singlebhd_rr}
# DELTA
# Test delta comparison function with fake values
comparison_yld_singlebhd_rr_delta <-
  healthiar::compare_yld(
    approach_comparison = "delta",
    exp_central_1 = 8.85, 
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# View(comparison_yld_singlebhd_rr_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta ,
               result_vector_alternative = c(387, 205, 564)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_delta_geo <-
  healthiar::compare_yld(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yld_singlebhd_rr_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_delta_geo ,
               result_vector_alternative = c(591, 313, 861)) # Result on 26 June 2024


#PIF
# Test pif comparison function with fake values
comparison_yld_singlebhd_rr_pif <-
  healthiar::compare_yld(
    approach_comparison = "pif",
    exp_central_1 = 8.85,  
    exp_central_2 = 6,
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after")

# View(comparison_yld_singlebhd_rr_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif ,
               result_vector_alternative = c(391,206,573)) # Result on 16 May 2024

# Additionally check that the first scenario produces the same results as above
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_singlebhd[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_singlebhd_rr_pif_geo <-
  healthiar::compare_yld(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),
    exp_central_2 = list(6, 6.5),
    cutoff_central = 5,    
    bhd_central_1 = 25000,
    bhd_central_2 = 25000,
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear", 
    dw_central = 0.5,
    duration_central = 1,
    info_1 = "PM2.5_yld_before",
    info_2 = "PM2.5_yld_after",
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yld_singlebhd_rr_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_singlebhd_rr_pif_geo ,
               result_vector_alternative = c(599, 315, 878)) # Result on 20 June 2024
```



### Lifetable

```{r comparison deaths lifetable, warning=TRUE}

# DELTA

comparison_deaths_lifetable_delta <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# View(comparison_deaths_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta,
               # result_vector_alternative = c(1922,1017,2801)) # Result on 16 May 2024
               result_vector_alternative = c(1915, 1013, 2795 )) # Result on 20 August 2024

# Additionally check that it produces the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact_rounded)  

# Iteration
comparison_deaths_lifetable_delta_geo <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2= airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_deaths_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_delta_geo ,
               # result_vector_alternative = c(2935, 1553, 4279)) # Result on 09 July 2024
               result_vector_alternative = c(2925, 1546, 4269)) # Result on 20 August 2024


# Additionally check that it produces the first scenario produce the same results as above
# comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  dplyr::filter(., geo_id_raw %in% "a") |> select(., impact)  |> pull(.) == bestcost_pm_deaths_lifetable_geluft[["health_main"]]$impact 
round(comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  
        dplyr::filter(geo_id_raw %in% "a") |> 
        select(impact)  |> 
        pull(), digits = 0) == 
  round(bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact)
# Absolute differences
abs(comparison_deaths_lifetable_delta_geo[["health_detailed"]][["scenario_1"]][["health_detailed"]][["raw"]] |>  
      dplyr::filter(geo_id_raw %in% "a") |> select(impact)  |> pull() 
    - bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact)
# Absolute differences are negligeable (< 0.01, or < 0.0001%)
      

# PIF
comparison_deaths_lifetable_pif  <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    approach_exposure_1 = "single_year",
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    approach_exposure_2 = "single_year",
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    min_age = 20)

# View(comparison_deaths_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif ,
               # result_vector_alternative = c(1943,1023,2847)) # Result on 16 May 2024
               result_vector_alternative = c(1935, 1018, 2837 )) # Result on 20 August 2024

# Additionally check that scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_deaths_lifetable_airqplus[["health_main"]]$impact_rounded)  # AirQ+ result


# Iteration
comparison_deaths_lifetable_pif_geo <-
  healthiar::compare_deaths_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_deaths_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_deaths_lifetable_pif_geo ,
               # result_vector_alternative = c(2974, 1563, 4362)) # Result on 09 July 2024
               result_vector_alternative = c(2961, 1556, 4346)) # Result on 20 AUgust 2024
```



```{r comparison YLL lifetable}

# DELTA 
comparison_yll_lifetable_delta  <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    approach_newborns_1 = "without_newborns",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019,
    approach_exposure_2 = "single_year",
    approach_newborns_2 = "without_newborns",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20)

# View(comparison_yll_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta,
               # result_vector_alternative = c(20421,10806,29763)) # Results on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Results on 20 August 2024


# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["health_main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["health_main"]]$impact_rounded) # AirQ+ results

# Iteration
comparison_yll_lifetable_delta_geo <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yll_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Results on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Results on 20 August 2024

# PIF
comparison_yll_lifetable_pif <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    approach_exposure_1 = "single_year",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    approach_exposure_2 = "single_year",
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20)

# View(comparison_yll_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978 )) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif[["health_detailed"]][["scenario_1"]],
               # result_vector_alternative = bestcost_pm_yll_lifetable_geluft[["health_main"]]$impact_rounded) # OLD GeLuft variable
               result_vector_alternative = bestcost_pm_yll_exposure_single_year_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_yll_lifetable_pif_geo <-
  healthiar::compare_yll_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2))

# View(comparison_yll_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yll_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 08 July 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024
```



```{r comparison YLD lifetable}

# DELTA
comparison_yld_lifetable_delta  <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta ,
               # result_vector_alternative = c(20421, 10806, 29763)) # Result on 16 May 2024
               result_vector_alternative = c(21644, 11340, 31860)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["health_main"]]$impact_rounded) 

# Iteration
comparison_yld_lifetable_delta_geo <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_delta_geo ,
               # result_vector_alternative = c(31190, 16500, 45472)) # Result on 08 July 2024
               result_vector_alternative = c(33041, 17309, 48639)) # Result on 20 August 2024

# PIF
comparison_yld_lifetable_pif <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif ,
               # result_vector_alternative = c(20650, 10870, 30257)) # Result on 16 May 2024
               result_vector_alternative = c(21698, 11354, 31978)) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_yld_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_yld_lifetable_pif_geo <-
  healthiar::compare_yld_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_yld_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_yld_lifetable_pif_geo ,
               # result_vector_alternative = c(31601, 16613, 46359)) # Result on 26 June 2024
               result_vector_alternative = c(33137, 17335, 48851)) # Result on 20 August 2024

```


```{r comparison DALY lifetable}

# DELTA
comparison_daly_lifetable_delta  <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5, # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_delta)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta ,
               # result_vector_alternative = c(20421*2,10806*2,29763*2)) # Result on 16 May 2024
               result_vector_alternative = c(43288, 22679, 63720)) # Result on 20 August 2024

# Additionally check that it producesthe first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta[["health_detailed"]][["scenario_1"]] ,
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["health_main"]]$impact_rounded) 

# Iteration
comparison_daly_lifetable_delta_geo <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "delta",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_delta_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_delta_geo ,
               # result_vector_alternative = c(31190*2, 16500*2, 45472*2)) # Result on 08 July 2024
               result_vector_alternative = c(66082, 34618, 97279)) # Result on 20 August 2024

# PIF
comparison_daly_lifetable_pif <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = 8.85, # Fake data just for testing purposes
    prop_pop_exp_1 = 1, # Fake data just for testing purposes
    exp_central_2 = 6, # Fake data just for testing purposes
    prop_pop_exp_2 = 1, # Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019, 
    info_1 = NULL,
    info_2 = NULL, 
    min_age = 20,
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_pif)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif ,
               # result_vector_alternative = c(20650*2, 10870*2, 30257*2)) # Result on 16 May 2024
               result_vector_alternative = c(43396, 22708, 63957 )) # Result on 20 August 2024

# Additionally check that the first scenario produce the same results as above
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif[["health_detailed"]][["scenario_1"]],
               result_vector_alternative = bestcost_pm_daly_lifetable_geluft[["health_main"]]$impact_rounded)

# Iteration
comparison_daly_lifetable_pif_geo <-
  healthiar::compare_daly_from_lifetable(
    approach_comparison = "pif",
    exp_central_1 = list(8.85, 8.0),# Fake data just for testing purposes
    exp_central_2 = list(6, 6.5),# Fake data just for testing purposes
    cutoff_central = 5,   # PM2.5=5, WHO AQG 2021 
    rr_central = 1.118,
    rr_lower = 1.060,
    rr_upper = 1.179,
    erf_increment = 10, 
    erf_shape = "log_linear",
    first_age_pop_1 = 0,
    last_age_pop_1 = 99,
    deaths_male_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_1 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_1 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_1 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_1 = 2019, 
    first_age_pop_2 = 0,
    last_age_pop_2 = 99,
    deaths_male_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_male,
    deaths_female_2 = airqplus_pm_deaths_yll[["pop"]]$number_of_deaths_female,
    population_midyear_male_2 = lifetable_withPopulation[["male"]]$population, 
    population_midyear_female_2 = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis_2 = 2019,
    info_1 = input_data_mortality$pollutant[2],
    info_2 = input_data_mortality$pollutant[2], 
    min_age = 20,
    geo_id_raw = c("a", "b"),
    geo_id_aggregated = rep("ch", 2),
    duration_central = 100,
    dw_central = 1)

# View(comparison_daly_lifetable_pif_geo)

# No study to compare bestcost results
# Check only if results stay the same overtime despite developments
check_bestcost(result_list_bestcost = comparison_daly_lifetable_pif_geo ,
               # result_vector_alternative = c(31601*2, 16613*2, 46359*2)) # Result on 26 June 2024
               result_vector_alternative = c(66275, 34671, 97702)) # Result on 20 August 2024

```
# Cost

```{r Monetize a simple case}
# Monetize only with valuation
bestcost_pm_copd_costs <- 
  healthiar::include_cost(output = bestcost_pm_copd, 
                          valuation = 1000)



# Monetize with all arguments (including discount)
bestcost_pm_copd_cost_discount <- 
  healthiar::include_cost(approach_discount = "direct",
                          output = bestcost_pm_copd, 
                          discount_shape = "exponential",
                          corrected_discount_rate = 0.01,
                          time_period = 5,
                          valuation = 1000)

# Monetize with all arguments (including discount)
bestcost_pm_copd_cost_discount_single_value <- 
  healthiar::include_cost(approach_discount = "direct",
                          impact = 2E4, 
                          discount_shape = "exponential",
                          corrected_discount_rate = 0.03,
                          time_period = 20,
                          valuation = 1)
check_general(bestcost_pm_copd_cost_discount_single_value$cost_rounded,
              14877)
# According to ChatGPT, the result should be 14877. 5 Dec 2024



# Discounting without valuation (=1)
bestcost_pm_yll_lifetable_geluft_discount <- 
  healthiar::include_cost(approach_discount = "indirect",
                          output = bestcost_pm_yll_exposure_single_year_lifetable_geluft, 
                          discount_shape = "exponential",
                          corrected_discount_rate = 0.01,
                          valuation = 1)

check_general(bestcost_pm_yll_lifetable_geluft_discount[["cost_main"]]$cost_rounded,
              c(26493, 13877, 39006))
# Result on 13 Dec 2025. Same result as discouting in attribute() (deprecated).

```

# Export 

```{r eval=FALSE, include=FALSE}
# write.csv2(lifetable_airqplus,
#             "../testing/output/lifetable_airqplus_2019_ch.csv", 
#             row.names = FALSE)
```

# Other

```{r Illustration integrate compare() in attribute()}

# Benefit of this: compare the two conceptionally different approaches
 
# case1 <- attribute(approach= cutoff in exposure)

# case2 <- attribute(approach = delta approach/cutoff in ERF)

# difference impact <- case1[[impact]] - case2[[impact]]
```
