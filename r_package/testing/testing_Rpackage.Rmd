---
title: "Testing of BEST-COST R package"
author: "Alberto Castro & Axel Luyten"
output: html_document
---
# Goal
Recreate calculation of AirQ+ with {bestcost}. For this, all necessary input data is loaded and manipulated to fit the required formats of {bestcost}. Then, the health impacts are calculated.

Pending
- Create table comparing the AirQ+ and bestcost results to always control that we do not deviate.
- Compare morbidity (not only mortality)
- healthiar vs. geluft in the package
- test

# Load packages

Load the Rdata file that contains all variables needed to run this script.
```{r load data & bestcost package}
load("../testing/input/input_data_for_testing_Rpackage.RData")

# Load package
devtools::load_all(export_all = FALSE)
```


The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}

# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)
library(zoo)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)
```

```{r Install own package from github, eval=FALSE, include=FALSE}
# Install own package from github as suggested here
# https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT when prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           # Branch (by default "HEAD")
                           # Other usual branches 
                           # "63-simplification-of-the-code"
                           # "Variable_names"
                           # "Small_code_changes"
                           ref = "HEAD",
                           force = TRUE)
}

# to quantify and monetize health impacts (own package)
library(bestcost)
# Update R package documentation
# devtools::document()
```


```{r load current version of bestcost from local source, eval=FALSE, include=FALSE}
detach("package:bestcost", unload = TRUE) # detach bestcost
# Save current state of package as .zip file (e.g. to directly test changes in functions)
devtools::build(binary = TRUE, path = "../testing/input/") 
# Install package from source
install.packages("../testing/input/bestcost_0.0.0.1.zip", repos=NULL, type='source')
# Load updated package
library(bestcost)
load_all(export_all = TRUE)
```

```{r Test probability of dying}
# Use function
prob_dying_airqplus <- 
  bestcost::get_prob_dying(
    first_age_pop = 0,
    last_age_pop = 14,
    interval_age_pop = 5,
    population_midyear = airqplus_deaths_pop_multipleYear$mi,
    deaths = airqplus_deaths_pop_multipleYear$di,
    fraction_of_year_lived = 0.5
  )
```


# Calculate health impacts

```{r absolute risk}

impact_annoyance_expDistribution_raw <- 
  bestcost::assess_impact_absolute_risk (
    exp = c(57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    pop_exp = c(387500, 286000, 191800, 72200, 7700), # Values as example provided by NIPH
    erf_shape = "quadratic",
    erf_parameters = c(78.9270, -3.1162, 0.0342),
    info_pollutant = "road_noise", 
    info_outcome = "highly_annoyance")


```


```{r morbidity using exposure distribution}

impact_morbidity_expDistribution_raw <- list()


for(i in 1:nrow(input_data_morbidities)){
  impact_morbidity_expDistribution_raw[[input_data_morbidities$year[i]]][[input_data_morbidities$rr_id[[i]]]] <-
  bestcost::assess_impact_single(
    exp = c(53, 57.5, 62.5, 67.5, 72.5, 77.5),# Values as example provided by NIPH
    prop_pop_exp = c(0.8187, 0.0743, 0.0549, 0.0368, 0.0138, 0.0015), # Values as example provided by NIPH
    cutoff = 53, # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
    bhd = 5269.46,
    rr = c(1.08, 1.07, 1.09),
    rr_increment = 10, 
    erf_shape = "loglinear", 
    info_pollutant = "noise", 
    info_outcome = "YLD")
  }


```



```{r impact morbidity}
impact_morbidities_raw <- list()


for(i in 1:nrow(input_data_morbidities)){
  impact_morbidities_raw[[input_data_morbidities$year[i]]][[input_data_morbidities$rr_id[[i]]]] <-
  bestcost::assess_impact_single(
    exp = input_data_morbidities$exp[i],  # PM2.5=8.30=limit LRV CH, NO2=16.32=mean conc. in CH in 2019
    cutoff = input_data_morbidities$cutoff[i],    # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
    bhd = input_data_morbidities$bhd_absolute[i],
    rr = unlist(input_data_morbidities[i, 
                            c("rr_mean", "rr_lowci", "rr_highci")]) ,
    rr_increment = 10, 
    erf_shape = "loglinear", 
    info_pollutant = input_data_morbidities$pollutant[i], 
    info_outcome = input_data_morbidities$outcome_metric[i])
  }


impact_morbidities_edited <- 
  # Bind rows within the nested lists
  impact_morbidities_raw %>%
  purrr::map(., ~ dplyr::bind_rows(., .id = "rr_id")) 

impact_morbidities_comparative <- list()
for (r in c("2019", "whoaqg21")){ 
  # Substract the impacts for the scenarios
  impact_morbidities_comparative[[paste0(r, "_whoaqg21")]] <- 
    dplyr::left_join(impact_morbidities_edited[[r]],
                     impact_morbidities_edited[["whoaqg21"]][c("rr_id", "ci", "rr", "exp", "impact")], 
                     by = c("rr_id", "ci", "rr"), 
                     suffix = c("_ref", "_whoaqg21")) %>%
    dplyr::mutate(ref = r,
                  impact_diff = impact_ref - impact_whoaqg21)
}

impact_morbidities <- 
  impact_morbidities_comparative %>%
  dplyr::bind_rows(.) %>%

  # Remove columns 
  dplyr::select(-rr_forPaf) %>%

  
  # Pivot wider the ci
  tidyr::pivot_wider(
    values_from = c(rr, paf,
                    impact_ref, impact_whoaqg21, impact_diff), 
    names_from = ci) %>%
  # Paste the CIs
  dplyr::mutate(
    rr_meanCI = paste_round_CI(rr_mean, rr_lowci, rr_highci, 3),
    impact_ref_meanCI = paste_round_CI(impact_ref_mean, impact_ref_lowci, impact_ref_highci, 0),
    impact_whoaqg21_meanCI = paste_round_CI(impact_whoaqg21_mean, impact_whoaqg21_lowci, impact_whoaqg21_highci, 0),
    impact_diff_meanCI = paste_round_CI(impact_diff_mean, impact_diff_lowci, impact_diff_highci, 0)) %>%
  
      # Pivot wider the impacts
  tidyr::pivot_wider(
    values_from = 
      c(contains("_ref"),contains("_diff")),
    names_from = ref) %>%
  
    # Left join to add further information on RR
  dplyr::left_join(., rr_data, 
                   by = c( "rr_id", 
                          paste0("rr_", c("mean", "lowci", "highci"))),
                   relationship = "many-to-one") %>%
     # Left join to add further information on bhd
  dplyr::left_join(., unique(input_data_morbidities [, c("outcome_id", "bhd_absolute", "source_bhd", "choice_bhd")]), 
                   by = c("outcome_id", "bhd" = "bhd_absolute"),
                   relationship = "many-to-one") %>%
  # Left join to add label in German of outcomes
  dplyr::left_join(., codebook,
                   by = "outcome_id",
                   relationship = "many-to-one") %>%
  
  # Order columns 
  dplyr::select(pollutant, term, 
                bhd,
                rr_meanCI, 
                contains("impact_diff_meanCI"),
                contains("impact_ref_meanCI"), 
                impact_whoaqg21_meanCI,
                everything())

```



```{r mortality using exposure distribution}
impact_mortality_expDistribution_raw <- list()


# Calculate mortality impacts using bestcost function

#for(i in 1:nrow(input_data_mortality)){  # Use this if you want to evaluate multiple RRs
for(i in 2){                           # Use this if you want to evaluate only one RR
  impact_mortality_expDistribution_raw[[input_data_mortality$year[i]]][[input_data_mortality$rr_id[[i]]]] <-
  
    bestcost::assess_mortality_lifetable(
    exp = c(8, 9, 10), # Fake data just for testing purposes
    prop_pop_exp = c(0.2, 0.3, 0.5), # Fake data just for testing purposes
    cutoff = input_data_mortality$cutoff[i],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
    rr = unlist(input_data_mortality[i,
                                      c("rr_mean", "rr_lowci", "rr_highci")]),
    rr_increment = 10, 
    erf_shape = "loglinear",
    first_age_pop = 0,
    last_age_pop = 99,
    interval_age_pop = 1,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_male = lifetable_withPopulation[["male"]]$population, 
    population_female = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis = 2019, 
    info_pollutant = input_data_mortality$pollutant[i], 
    min_age = input_data_mortality$min_age[i],
    max_age = input_data_mortality$max_age[i],
    corrected_discount_rate = 0)
}

head(impact_mortality_expDistribution_raw$`2019`$`PM2.5_premature deaths_all causes_adults_main_ERS-ISEE_2022_selected`$deaths$impact) # to check results stay the same
#4250 1537 2911
```


```{r impact mortality}
impact_mortality_raw <- list()


# Calculate mortality impacts using bestcost function

#for(i in 1:nrow(input_data_mortality)){  # Use this if you want to evaluate multiple RRs
for(i in 2){                           # Use this if you want to evaluate only one RRs
  impact_mortality_raw[[input_data_mortality$year[i]]][[input_data_mortality$rr_id[[i]]]] <-
  
    bestcost::assess_mortality_lifetable(

    exp = input_data_mortality$exp[i], # PM2.5=8.30=limit LRV CH, NO2=16.32=mean conc. in CH in 2019
    cutoff = input_data_mortality$cutoff[i],   # PM2.5=5, NO2=10, i.e. WHO AQG 2021 
    rr = unlist(input_data_mortality[i,
                                      c("rr_mean", "rr_lowci", "rr_highci")]),
    rr_increment = 10, 
    erf_shape = "loglinear",
    first_age_pop = 0,
    last_age_pop = 99,
    interval_age_pop = 1,
    prob_natural_death_male = lifetable_withPopulation[["male"]]$death_probability_natural,
    prob_natural_death_female = lifetable_withPopulation[["female"]]$death_probability_natural,
    prob_total_death_male = lifetable_withPopulation[["male"]]$death_probability_total,
    prob_total_death_female = lifetable_withPopulation[["female"]]$death_probability_total,
    population_male = lifetable_withPopulation[["male"]]$population, 
    population_female = lifetable_withPopulation[["female"]]$population, 
    year_of_analysis = 2019, 
    info_pollutant = input_data_mortality$pollutant[i], 
    min_age = input_data_mortality$min_age[i],
    max_age = input_data_mortality$max_age[i],
    corrected_discount_rate = 0)
}

impact_mortality_edited <- list()

impact_mortality_edited[["deaths"]] <- 
  # Extract only nested  lists with the name "deaths"  
  purrr::map_depth(impact_mortality_raw, 2, "deaths")
# Same with "yll"  
impact_mortality_edited[["yll"]] <- 
  purrr::map_depth(impact_mortality_raw, 2, "yll")

impact_mortality_edited <- impact_mortality_edited %>%
  # Unlist assigning id
  purrr::map(., map,  ~ dplyr::bind_rows(., .id = "rr_id")) %>%
  purrr::map(.,  ~ dplyr::bind_rows(., .id = "case")) %>%
  dplyr::bind_rows(., .id = "outcome_metric_short") %>%
  # Now list only scenario
  split(., .$case) 


# Put together the different scenarios
impact_mortality_comparative <- list()

for (r in c("2019", "whoaqg21")){ 
  # Substract the impacts for the scenarios
  impact_mortality_comparative[[paste0(r, "_whoaqg21")]] <- 
    dplyr::left_join(impact_mortality_edited[[r]],
                     impact_mortality_edited[["whoaqg21"]][c("rr_id", "ci", "impact", "impact_beforeRounding" ,"outcome_metric_short", "exp")], 
                     by = c("outcome_metric_short", "rr_id", "ci"), 
                     suffix = c("_ref", "_whoaqg21")) %>%
    dplyr::mutate(ref = r,
                  impact_diff = impact_ref - impact_whoaqg21,
                  impact_beforeRounding_diff = impact_beforeRounding_ref - impact_beforeRounding_whoaqg21)
  }

impact_mortality <- 
  impact_mortality_comparative %>%
  dplyr::bind_rows(.) %>%
  # Remove non relevant columns
  dplyr::select(-case, -rr_ci) %>%
  
  # Pivot wider CI
  tidyr::pivot_wider(
    values_from = c(rr, rr_forPaf, paf,
                    impact_ref, impact_whoaqg21, impact_diff,
                    impact_beforeRounding_ref, impact_beforeRounding_whoaqg21, impact_beforeRounding_diff), 
    names_from = ci) %>%
  # Paste the CIs
  dplyr::mutate(
    rr_meanCI = paste_round_CI(rr_mean, rr_lowci, rr_highci, 3),
    impact_ref_meanCI = paste_round_CI(impact_ref_mean, impact_ref_lowci, impact_ref_highci, 3),
    impact_whoaqg21_meanCI = paste_round_CI(impact_whoaqg21_mean, impact_whoaqg21_lowci, impact_whoaqg21_highci, 0),
    impact_diff_meanCI = paste_round_CI(impact_diff_mean, impact_diff_lowci, impact_diff_highci, 0),
    # bhd as NA just to match with structure of morbidities
    bhd = NA) %>%

    
  # Left join to add further information on RR
  dplyr::left_join(., rr_data, 
                   by = c("info_pollutant" = "pollutant", "rr_id", "rr_increment",
                          paste0("rr_", c("mean", "lowci", "highci"))),
                   relationship = "many-to-one")%>%
  # Change outcome_id to ensure match with codebook
  dplyr::mutate(
    outcome_id = ifelse(outcome_metric_short %in% "yll",
                        gsub("premature deaths", "yll", outcome_id),
                        outcome_id)) %>%
  # Order columns 
  dplyr::select(info_pollutant, ref, outcome_id, rr_source, 
                term, bhd, rr_meanCI, 
                contains("impact_diff_meanCI"),
                contains("impact_ref_meanCI"), 
                impact_whoaqg21_meanCI,
                everything()) %>%
  # Order rows by label
  dplyr::arrange(desc(info_pollutant), ref, outcome_id, rr_source)

```

# Export 

```{r eval=FALSE, include=FALSE}
write.csv2(lifetable_airqplus,
            "../testing/output/lifetable_airqplus_2019_ch.csv", 
            row.names = FALSE)
```
