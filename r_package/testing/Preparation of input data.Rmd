---
title: "Preparation of input data"
author: "Axel Luyten"
date: "`r Sys.Date()`"
output: pdf_document
---

This script prepares the input data for the use in the {bestcost} functions. The R Environment (including all variables created during the script) is exported in the end in a ".Rdata" file.


The R script required the loading of certain R packages. 
```{r Load packages, include=FALSE}

# Clear R environment
rm(list = ls())

# Load required packages

# to assess performance
library(profvis)
library(bench)
library(microbenchmark)

# to manipulate data
library(readxl)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(tibble)

library(zoo)

# to visualize results
library(ggplot2)

## to export tables in excel format
library(openxlsx)

## to load own packages
library(credentials)
library(gitcreds)
library(devtools)

# Install own package from github as suggested here
# https://stackoverflow.com/a/71846333/6104907
if(!"bestcost" %in% installed.packages()[, "Package"]){
  #gitcreds::gitcreds_set()
  #usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com") # run if installation doesn't work
  credentials::set_github_pat() # paste github PAT when prompted
  devtools::install_github(repo = "best-cost/best-cost_WPs",
                           subdir = "/r_package/bestcost",
                           # Branch (by default "HEAD")
                           # Other usual branches 
                           # "63-simplification-of-the-code"
                           # "Variable_names"
                           # "Small_code_changes"
                           ref = "HEAD",
                           force = TRUE)

}

# to quantify and monetize health impacts (own package)
library(bestcost)
# loads all functions in {bestcost}
#devtools::load_all() 
```

```{r Useful variables}

#Decide 
# the target increment (increase of concentration) of the pm CRFs 
# and PM fraction
per_target_pm <- 10 # ug/m3

# Define existing PM fractions
pm_fractions <- c("PM2.5", "PM10")

# Set targeted PM fraction
pm_target <- "PM2.5"

# PM fraction that is not targeted
pm_no_target <- pm_fractions[!pm_fractions %in% pm_target]

# Pollutants to be considered in the hra based on available exposure data
pollutants_hra <- c(pm_target, "NO2")

# Define sex
sex <-  c("male", "female")

# Define values in the confidence interval (ci)
ci <- c("mean", "lowci", "highci")

# Define Outcome groups
groups <-
  data.frame(
    agegroup = c("below1", "from30"),
    outcome_group = c("infants", "adults")
  )

outcomeGroups <- groups$outcome_group

#IMPORTANT: Year to be run in the analysis air pollution HRA (health risk assessment)
# This should be one (or more than one) from the years_withData
# Change it as needed
year_hra <- "2019"
```

```{r Functions}

# Create function to join mean CRF with the lower and upper bound
paste_CI <- 
  function(mean, low, high){
     paste0(mean," [", low, "; ", high, "]")
  }

# Create function to round keeping zeros in decimals (e.g. 2.0 instead of 2)
# We use sprintf() instead of round() because 
# the former keep the zeros unlike the latter
round_keeping0 <- 
  function(value, decimals){
    sprintf(paste0("%.", decimals, "f"), value)
  }
  
# Create function to round the values of the CRF and then paste
paste_round_CI <- 
  function(mean, low, high, decimals){
    paste0(round_keeping0(mean, decimals)," [",  
           round_keeping0(low, decimals), "; ", 
           round_keeping0(high, decimals), "]")
  }

# r Functions to rescale crf 

# Define function to re-scale the CRF regarding the considered increment
rescale_crf_increment <- 
  function(crf, per_original, per_target){
    rescaled_increment <- 
      exp(log(crf) * per_target / per_original)
  }

# Conversion factor for PM fraction
get_conversionFactor_pmFraction <-
  function(pm_original, pm_target){
    
    # Divide the percentage (%) by 100 to get the ratio (0.) 
    # And depending on the pm selected choose the default or the inverse form
    conversionFactor <- 
      ifelse(pm_original %in% "PM2.5" & pm_target %in% "PM10",
             1/(percentage_pm2.5_in_pm10/100),
             ifelse(pm_original %in% "PM10" & pm_target %in% "PM2.5",
                    percentage_pm2.5_in_pm10/100,
                    1))
  }

# Define function to re-scale the CRF regarding the considered PM fraction
rescale_conc_pmFraction <- 
  function(conc, pm_original, pm_target){
  # Get conversion factor for the PM fraction
    conversionFactor <- 
      get_conversionFactor_pmFraction(pm_original, pm_target)
    # Apply the conversion factor to get the concentration in the right fraction
    rescaled_fraction <- 
      conc * conversionFactor
  }

# Create function to get lifetable with population
get_lifetable_withPopulation <-
  function(lifetable, population, year_of_analysis, nonNatural_mortality){
        
    # Life table for 
    lifetable_withPopulation <- 
      # Join lifetable and population by age 
      dplyr::left_join(population,
                       lifetable,
                        by = "age")%>%
      dplyr::left_join(.,
                       nonNatural_mortality,
                       by = "age")%>%
      # Rename the column to show that it is total (and not only natural) mortality
      dplyr::rename("death_probability_total" = "death_probability")%>%
      # We close the last row assigning a 1 for probability to die and 
      # a 0 to probability to survive
      dplyr::mutate(death_probability_total = replace(death_probability_total, n(), 1),
                    death_probability_natural = death_probability_total * (1-percent_nonNatural))%>%
      # Add year to population column
      dplyr::rename("population_{year_of_analysis}" := population)
  }

```


# Load raw input data
```{r load raw data}

# Generic data
percentage_pm2.5_in_pm10 <- 
  read.csv("../testing/input/generic_data.csv", sep = ";") %>% 
  dplyr::filter(parameter_name %in% "percentage_pm2.5_in_pm10") %>%
  dplyr::select(value) %>%
  dplyr::pull()

# CRF data (inserted manually in the csv table)
crf_rawdata <- 
  read.csv("../testing/input/crf.csv",
           sep = ";",
           na.strings=c("NA", ""))

# Population data by age (To be used in the life table approach)
population_byAge_rawdata <-
  read.csv2("../testing/input/population/population_byAge_bySex_CH_2018_2019.csv") %>%
  # Rename columns
  dplyr::rename("age" = "Alter",
                "male_end2018" = "Mann.2018",
                "female_end2018" = "Frau.2018",
                "male_end2019" = "Mann.2019",
                "female_end2019" = "Frau.2019") %>%
  # Remove "Jahre" 
    dplyr::mutate(
      age = gsub(" Jahre| Jahr","", age)) #gsub() for pattern replacement

# Baseline health data 
bhd_rawdata <- 
  read.csv("../testing/input/bhd.csv", sep = ";")

# Read raw life table data
lifetable <- list()
for(s in sex){
  # Life table for 2019
  # Average of the period 2016-2020
  lifetable[[s]] <- 
    read.csv2(
      # The raw data are for the period 2013-2020 but we focused on 2015-2019 (five years period)
      paste0("../testing/input/life_tables/life_table_2013_2020_",
             s,
             ".csv"))
}


# Read raw non-natural mortality data for 2019 (average of the period 2009-2019)
nonNatural_mortality_rawdata<- 
   list(
     male = read.csv2("../testing/input/mortality/nonNatural_mortality_byAge_2009_2019_male.csv",
                      na.strings =".", 
                      check.names = FALSE),
     female = read.csv2("../testing/input/mortality/nonNatural_mortality_byAge_2009_2019_female.csv",
                        na.strings =".", 
                      check.names = FALSE))

# Read total mortality raw data for 2019 (average of the period 2009-2019)
total_mortality_rawdata <- 
  list(
    male = read.csv2("../testing/input/mortality/total_mortality_byAge_2009_2019_male.csv",
                     na.strings =".", 
                      check.names = FALSE),
    female = read.csv2("../testing/input/mortality/total_mortality_byAge_2009_2019_female.csv",
                       na.strings =".", 
                      check.names = FALSE))

# Concentration data
# Scenario
exp_rawdata <- 
  read.csv("../testing/input/exp.csv",
           sep = ";",
           na.strings=c("NA", ""))

# Counterfactual
cf_rawdata <- 
  # Read data
  read.csv("../testing/input/cf.csv",
           sep = ";",
           na.strings=c("NA", ""))

# Data sets from the AirQ+ manual (for testing of function get_prob_dying())

airqplus_deaths_pop_multipleYear <-
  read.csv2("../testing/input/life_tables/airqplus_manual_age0to14_multipleYear.csv")
airqplus_deaths_pop_singleYear <-
  read.csv2("../testing/input/life_tables/airqplus_manual_age0to14_singleYear.csv")
```

# Edit input data

## CRF data
```{r Edit CRF (rescale inclusive)}
crf_data <- 
  crf_rawdata %>%
  # Select only CRFs that are relevant 
  dplyr::filter(!is.na(choice_pair)) %>%
  # Reshape CRFs from wide to long (to enable editing CRFs by row)
  tidyr::pivot_longer(c(crf_mean, crf_lowci, crf_highci),
                      names_to = "ci",
                      names_prefix = "crf_", 
                      values_to = "crf") %>%
  # Add a copy of columns with the original values (before re-scaling)
  dplyr::mutate(
    crf_pollutant_original = pollutant,
    crf_original = crf,
    crf_per_original = crf_per,
  # Add the target CRF increment (default increase of concentration) 
  # for each pollutant
    crf_per_target =
      ifelse(pollutant %in% c(pm_fractions, "NO2"), 10, NA),
      # ifelse(pollutant %in% "BC", 0.44, NA))) %>%
      # ifelse(pollutant %in% "O3", , NA)))) %>% 
      # If O3 is included, the O3 increment is to be decided
  # Re-scale concentration of PM fractions in CRFs
    crf_per_rescaled = 
      rescale_conc_pmFraction(
        conc = crf_per_original,
        pm_original = crf_pollutant_original,
        pm_target = pm_target),
  # Re-scale to the target increment
    crf_rescaled = 
      rescale_crf_increment(
        crf = crf,
        per_original = crf_per_rescaled,
        per_target = crf_per_target),
    crf = crf_rescaled) %>%
  # Modify columns based on target
  dplyr::mutate(
    pollutant = 
      ifelse(pollutant %in% pm_no_target, 
             pm_target, 
             crf_pollutant_original),
    crf_per = 
      ifelse(!crf_per %in% crf_per_target, 
             crf_per_target, 
             crf_per)) %>%

  # Change format of source
  # Remove brackets and spaces
  dplyr::mutate(
    crf_source_rFormat = 
      paste(
        # First word
        stringr::word(crf_source, 1),
        # Year between brackets
        stringr::str_extract(crf_source, "(?<=\\().*(?=\\))"),
        sep = "_")) %>%
  
  # Add id for outcome as single variable
  tidyr::unite("outcome_id",
               outcome_metric, outcome_disease, outcome_group,
               na.rm = TRUE,
               remove = FALSE) %>%
  # Add id for pair as single variable
  tidyr::unite("pair_id",
               pollutant, outcome_id, choice_pair,
               na.rm = TRUE,
               remove = FALSE) %>% 
  # Add id for crf
  tidyr::unite("crf_id",
               pair_id, crf_source_rFormat, choice_crf,
               sep = "_", 
               na.rm =TRUE,
               remove = FALSE) %>%
  # Keep only unique CRFs (id, value and CI category) to avoid duplicates
  dplyr::distinct(., crf_id, crf, ci, 
                  .keep_all = TRUE) %>%
  # Change position of some columns
  dplyr::relocate(c(crf_per, crf_unit), .after=crf) %>%
# Pivot wider to have ci in columns
  tidyr::pivot_wider(values_from = c(crf, crf_original, crf_rescaled), 
                     names_from = ci)

# Store the relevant pollutant-outcomes pairs 

# Pollutant-outcome pairs to be considered in the main analysis or in the appendix
choice_pairs_main <- crf_data %>% 
  dplyr::filter(choice_pair %in% "main") %>% 
  select(pair_id) %>% 
  unique() %>% 
  pull()

choice_pairs_appendix <- crf_data %>% 
  dplyr::filter(choice_pair %in% "appendix") %>%
  select(pair_id) %>% 
  unique() %>% 
  pull()

choice_pairs_all <- c(choice_pairs_main, choice_pairs_appendix)

# CRFs to be considered in the main analysis or only as sensitivity analysis
choice_crf_main_selected <- 
  crf_data %>% 
  dplyr::filter(pair_id %in% choice_pairs_main & 
                  choice_crf %in% "selected") %>% 
  select(crf_id) %>% unique() %>% pull()
choice_crf_main_sensitivity <- 
  crf_data %>% 
  dplyr::filter(pair_id %in% choice_pairs_main & 
                  choice_crf %in% "sensitivity") %>% 
  select(crf_id) %>% unique() %>% pull()


choice_pairs <- c("main", "appendix")
choice_crfs <- c("selected", "sensitivity")

# Select CRF data for all-cause mortality (removing disease specific)
crf_data_allCauseMortality <-
  dplyr::filter(crf_data,
    outcome_metric %in% "premature deaths" &
    outcome_disease %in% "all causes")

crf_data_morbidities<- 
   dplyr::filter(crf_data,
    !outcome_metric %in% "premature deaths")
```

## Population data 
```{r Edit population data by age for life table}

# Create a list with two elements to split male and female data (for seperate life table calculations)
population_byAge <- 
  list()

for (s in sex){
  population_byAge[[s]] <- 
    population_byAge_rawdata %>%
    # Select relevant columns
    dplyr::select(age, starts_with(s)) %>%
    # Estimate the population at the middle of 2019 by 
    # calculating the average between the population at the end of 2018 and 2019
    dplyr::mutate(
      population = rowMeans(across(contains(s)), na.rm = TRUE)) %>%
    # Remove male and female columns used to calculate the mean
    dplyr::select(-contains(s)) %>%
    # Remove "und mehr" (and more)
    dplyr::mutate(
      age = gsub(" und mehr","", age ))
}

total_population <- 
  sum(
    sum(population_byAge[["male"]]$population),
    sum(population_byAge[["female"]]$population))
```

## Baseline morbidity data

```{r Edit bhd_data}

# Adapt the rawdata as needed
bhd_data <- 
  bhd_rawdata %>%
  dplyr::mutate(
    # Change format of year
    bhd_year = as.character(bhd_year),
    # Calculate the rate based on the absolute value
    # Already available in the csv file but to be overwritten  
    # to update the information.
    bhd_rate = round((bhd_absolute/total_population)*1E5, 2)) %>%
  # Add bhd_id
  tidyr::unite("outcome_id",
               outcome_metric, outcome_disease, outcome_group,
               sep = "_", 
               na.rm =TRUE,
               remove = FALSE) %>%
  # Filter the data to remove "all ages" in some of the GBD data
  dplyr::filter(!(source %in% "IHME (2020)" & 
                    outcome_disease %in% c("lung cancer",
                                           "ischemic heart disease",
                                           "stroke",
                                           "diabetes (type 2)",
                                           "dementia")
                  &  bhd_age %in% "all"))

# Select only morbidity (mortality is to be done with life tables)
bhd_data_morbidity <- bhd_data %>%
  # Filter for relevant rows 
  dplyr::filter(!outcome_metric %in% "premature deaths")
```


## Baseline mortality data

```{r Edit life table}
#TODO: AirQ+ require the death rate by age to derive probability of surviving
# instead of using the probability of dying as here. 
# The AirQ+ method has to be accomodated here. 
# See  formulas here: https://www.who.int/europe/publications/i/item/WHO-EURO-2020-1559-41310-56212

for(s in sex){
  # Life table for 2019
  # Average of the period 2016-2020
  lifetable[[s]] <- lifetable[[s]] %>% 
  # Life table for 2019
  # Average of the period 2016-2020
    # Rename columns
    dplyr::rename("age" = "AGE..X." ,
                  "indicator" = "INDICATOR",
                  "year"  = "PERIOD",
                  "value" = "VALUE") %>%
    # Convert value to numeric
    dplyr::mutate(value = as.numeric(value)) %>%
    # Filter only columns for years within the period 2015 - 2019
    dplyr::filter(year %in% c(2015:2019)) %>%
    # Obtain mean of the period 2016-2020 as value for 2019
    dplyr::group_by(indicator, age) %>%
    dplyr::summarize(mean= mean(value), .groups = "drop") %>%
    # Wider form
    tidyr::pivot_wider(names_from = indicator, values_from = mean) %>%
    # Rename column probability of dying
    dplyr::rename("death_probability" = "Q(X)") %>%
    # Select columns probability of dying (drop the other indicators)
    dplyr::select(age, death_probability) %>% 
    dplyr::mutate(age=as.character(age))
    }

```

```{r Edit non-natural mortality data}

#Create a copy of rawdata to edit them
nonNatural_mortality <- nonNatural_mortality_rawdata 
total_mortality <- total_mortality_rawdata 
# Create list joining non-natural and total mortality data
mortality_data_beforeCorrecting <- list()
mortality_data <- list()

# Calculate average by age in non-natural and total mortality
for(s in sex){
    # Non-natural mortality
    nonNatural_mortality[[s]] <- 
      nonNatural_mortality[[s]] %>%
      # Select columns keeping only those 10 year before (2010-2019)
      dplyr::select(all_of(c("Age", as.character(2010:2019)))) %>%
      # Calculate average by age
      dplyr::mutate(mean_nonNatural = 
                      rowMeans(subset(nonNatural_mortality[[s]], 
                                      select = -Age), 
                               na.rm = TRUE))
    
    # Total mortality
    total_mortality[[s]] <- 
      total_mortality[[s]] %>%
      # Select columns keeping only those 10 year before (2010-2019)
      dplyr::select(all_of(c("Age", as.character(2010:2019)))) %>%
      # Calculate average by age
      dplyr::mutate(mean_total = 
                      rowMeans(subset(total_mortality[[s]], 
                                      select = -Age), 
                               na.rm = TRUE))
 # Joined data set with total and natural mortality together
  mortality_data_beforeCorrecting[[s]] <-
    # Add row from non-natural mortality
    dplyr::left_join(total_mortality[[s]][, c("Age", "mean_total")],
                     nonNatural_mortality[[s]][, c("Age", "mean_nonNatural")],
                     by = "Age") %>%
    dplyr::rename("age" = "Age") %>%
    # Calculate percentage of deaths from non-natural mortality
    dplyr::mutate(percent_nonNatural_raw = mean_nonNatural / mean_total)
    
    
    # Calculate the moving average (mean of 5 ages) to correct yearly deviations
  mortality_data[[s]] <-
    mortality_data_beforeCorrecting[[s]] %>%
    dplyr::mutate(percent_nonNatural_movingAverage = 
                    zoo::rollmean(percent_nonNatural_raw, 
                                  k = 5, 
                                  fill = NA)) %>%
    # The three first lines of the moving average are special cases
    # Edit them manually
    dplyr::mutate(percent_nonNatural = 
                    ifelse(age == 0, percent_nonNatural_raw,
                           ifelse(age == 1, mean(percent_nonNatural_raw[2:4], 
                                                 na.rm =TRUE),
                                  ifelse(age == 2, mean(percent_nonNatural_raw[2:5],
                                                        na.rm =TRUE),
                                         percent_nonNatural_movingAverage)))) %>%
    # Keep only age and percentage of non-natural deaths, which the only data needed.
    dplyr::select(age, percent_nonNatural)
}
```


```{r Join lifetable and population data}

lifetable_withPopulation <- list()

for(s in sex){
  lifetable_withPopulation[[s]] <-
    get_lifetable_withPopulation(
      lifetable = lifetable[[s]],
      population = population_byAge[[s]],
      nonNatural_mortality = mortality_data[[s]],
      year_of_analysis = 2019)

}
```

```{r Create lifetable as in Airq+}

#Create list to derive natural deaths
natural_mortality <- list()

for(s in sex){
  natural_mortality[[s]] <- 

    # Join total and non natural deaths
    dplyr::left_join(
      dplyr::select(total_mortality[[s]], Age,  mean_total),
      dplyr::select(nonNatural_mortality[[s]], Age,  mean_nonNatural),
      by="Age")%>%
    # Rename age
    dplyr::rename(age = Age) %>%
    # Delete total row
    dplyr::filter(!age %in% "Total") %>%
    # Replace NA with 0
    dplyr::mutate(mean_nonNatural = 
                    ifelse(is.na(mean_nonNatural), 0, mean_nonNatural)) %>%
    # Calculate difference between total and non natural
    dplyr::mutate(natural_deaths = round(mean_total-mean_nonNatural, 0)) %>%
    # Select only relevant columns
    dplyr::select(age, natural_deaths)
  
}

natural_mortality <- 
  dplyr::left_join(natural_mortality[["male"]],
                   natural_mortality[["female"]],
                   by = "age",
                   suffix = c("_male", "_female"))

# Population data in life table  
lifetable_airqplus <- 
  # Convert list into data frame
  dplyr::left_join(population_byAge[["male"]], 
                   population_byAge[["female"]],
                   by = "age",
                   suffix = c("_male", "_female")) %>%
  # Round population values
  dplyr::mutate(population_male =round(population_male, 0),
                population_female = round(population_female, 0)) %>%
  # Add mortality data
  dplyr::left_join(.,
                   natural_mortality,
                   by = "age") %>%
  # Convert age to numeric (previously character)
  dplyr::mutate(age = as.numeric(age)) %>%
  # Duplicate column for age as in AirQ+
  dplyr::mutate(age_end = age, .after = age)
```

## Concentration data

```{r exposure data scenario}

# Select relevant columns
# This data set will include other data beyond those from HRAs
exp_data <- 
  exp_rawdata %>%
  # Remove not relevant columns
  dplyr::select(-url, -hra, -estimation) %>%
  # Remove the columns for lower and upper bound of the concentration 
  # (not relevant but maybe later)
  dplyr::select(-exp_lowci, -exp_highci) %>%
  # Rename concentration column
  #dplyr::rename(exp = exp_mean) %>%
  # Add columns with the original values (before re-scaling)
  dplyr::mutate(
    pollutant_original = pollutant,
    exp_original = exp_mean,
    # Modify columns pollutant
    pollutant = 
      ifelse(pollutant %in% pm_no_target, 
             pm_target, 
             pollutant_original)) %>%
  # Convert the exposure
  dplyr::mutate(
    exp = 
      rescale_conc_pmFraction(
        conc = exp_original,
        pm_original = pollutant_original,
        pm_target = pm_target))
```

```{r Subsets exposure data scenario}

# Exposure data in a list form
exp_data_forLoop <- 
  exp_data %>%
  # Split (make list) by pollutant and year
  split(.$pollutant)%>%
  purrr::map(function(x) split(x, x$year))
```

```{r Counterfactual scenario}

cf_data <-
  cf_rawdata %>%
  # Take the relevant columns and rows 
  dplyr::filter(pollutant %in% c("PM2.5", "NO2")) %>%
  dplyr::select(pollutant, cf_mean, cf_unit) %>%
  # Rename cf_mean to cf 
  # TODO: to be changed if we used cf with CI
  dplyr::rename(cf = cf_mean)
  
```

```{r Create Codebook}
# Do not forget yll
codebook <- unique(bhd_data[, c("outcome_id", "mort_morb")]) 

#TODO: Here a table with the correspondence between 
# short names or ids (without spaces) 
# and labels (spaces and eventually capital letter)
# should be built
```

```{r prepare input data for function}
input_data <-
  # Join data sets of input data: exposure data, bhd data, counterfactual data
  dplyr::left_join(exp_data, crf_data, by="pollutant", 
                   suffix =c("_exp", "_crf"),
                   relationship = "many-to-many") %>%
  dplyr::left_join(., bhd_data, by="outcome_id",
                   suffix = c("", "_bhd"),
                   relationship = "many-to-many") %>%
  dplyr::left_join(., cf_data, by="pollutant",
                   relationship = "many-to-one")%>%
  # Add the minimum age and maximum age for each row 
  # (only relevant for mortality with lifetable)
  dplyr::mutate(
    min_age = ifelse(
      mort_morb %in% "mortality" & outcome_group_bhd %in% "adults", 
      20,
      NA),
    max_age = ifelse(
      mort_morb %in% "mortality" & outcome_group_bhd %in% "infants",
      0,
      NA))

input_data_morbidities <- 
  input_data %>%
  dplyr::filter(crf_id %in% crf_data_morbidities$crf_id)

input_data_mortality <- 
  input_data %>%
  dplyr::filter(crf_id %in% crf_data_allCauseMortality$crf_id)
```

```{r Export environment}
save.image(file = "../testing/input/input data for testing_Rpackage.RData")
```

